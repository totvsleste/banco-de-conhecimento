#INCLUDE "FileIO.CH"
#INCLUDE "PROTHEUS.CH"
#INCLUDE "fwschedule.ch"
#INCLUDE "CTBXCTB.CH"

#DEFINE D_PRELAN		"9"

STATIC __CtbSayApro := {}
STATIC aCtbIni 	 	:= {}
STATIC __CtbPosic 		:= {}
STATIC __aIsCtbJob 	:= Nil
Static lAprova
Static lX3Aprova := Nil


STATIC lFWCodFil := FindFunction("FWCodFil")
STATIC _lSomaOld
STATIC nQtdEntid 				//Quantidade de entidades
//Variaveis de controle da apuracao
STATIC __dDataLP
STATIC __lCW0LP

Static __aRealTempTable
Static __lConoutR	:= FindFunction("CONOUTR")

/*/

Ŀ
Funo    CtbCtaSup  Autor  Pilar S. Albaladejo    Data  08.11.99 
Ĵ
Descrio  Gera Codigo da Conta Superior                              
Ĵ
Sintaxe   CtbCtaSup(cCodigo)                                          
Ĵ
Retorno   cCod                                                        
Ĵ
 Uso       Generico                                                   
Ĵ
Parametros ExpC1 = Codigo da Conta                                    
ٱ


/*/
Function CtbCtaSup(cCodigo)

Local aAmbSave := GetArea()
Local aAmbCT1  := CT1->( GetArea() )
Local cCod
Local nCont

cCodigo			:= AllTrim( cCodigo )

dbSelectArea("CT1")
CT1->( dbSetOrder( 1 ) )

//Ŀ
// PONTO DE ENTRADA CTBCTASU                            
// Criado para gerar conta superior caso nao            
// siga a regra padrao do Sistema.                      
// Recebe em PARAMIXB a Conta Contbil atual.           
//
If ExistBlock("CTBCTASU")
	cCod := ExecBlock("CTBCTASU",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),20)
		If MsSeek(xFilial()+cCod,.f.)
			If CT1->CT1_CLASSE == "1"  //  Somente se for uma conta sinttica
				cCod := CT1->CT1_CONTA
				Exit
			EndIf
		EndIf
	Next
EndIf

RestArea( aAmbCT1 )
RestArea( aAmbSave )

Return cCod

/*/

Ŀ
Funo    CtbDigCont Autor  Pilar S. Albaladejo    Data  08.11.99 
Ĵ
Descrio  Gera digito de Controle                                    
Ĵ
Sintaxe   CtbDigCont(cCodigo)                                         
Ĵ
Retorno   cDig                                                        
Ĵ
 Uso       Generico                                                   
Ĵ
Parametros ExpC1 = Conta                                              
ٱ


/*/
Function CtbDigCont(cCodigo)

Local nSoma		:= 0
Local nResult	:= 0
Local nTam		:= 0
Local nDig 		:= 0
Local nCont := 0

Local cDig		:= ""

nTam := Len(Alltrim(cCodigo))

//Ŀ
// PONTO DE ENTRADA CTBDIGCT                            
// Criado para criar permitir gerao diferenciada de   
// dgito verificador para Conta Contbil.              
// Recebe em PARAMIXB a Conta Contbil.                 
//
If ExistBlock("CTBDIGCT")
	nDig := ExecBlock("CTBDIGCT",.F.,.F.,cCodigo)
	cDig := STR(nDig,1)
Else
	For nCont:=nTam To 1 Step -1
		nSoma:=Val(Substr(cCodigo,nCont,1))*nTam
		nResult+=nSoma
		nTam--
	Next
	nDig := MOD(nResult,11)
	cDig := If( nDig > 9 , "0" , STR(nDig,1) )
EndIf
Return cDig

/*/

Ŀ
Funo    CtbOk       Autor  Pilar S Albaladejo     Data  15.12.99 		     
Ĵ
Descrio Mensagem no botao Ok                                        			 
Ĵ
Sintaxe   CtbOk()                                                                
Ĵ
Retorno   Mensagem                                                               
Ĵ
 Uso       Generico                                                  			 
Ĵ
Parametros Nwnhum                                    	                 		 
ٱ


/*/
Function CtbOk()

Return MsgYesNo(OemToAnsi(STR0001),OemToAnsi(STR0002))  //"Confirma configurao dos parmetros?"###"Ateno!!"

/*/

Ŀ
Funo	 ReadCtbIni Autor  Pilar S. Albaladejo    Data  27/11/00 
Ĵ
Descrio Leitura do arquivo SIGACTB.INI para carregar array aCTBINI  
			 c/ configuracao da apropriacao de custos					  
Ĵ
Sintaxe	  ReadCTBIni												  
Ĵ
Retorno	  Array aCtbIni											  
Ĵ
 Uso		  Generico 												  
Ĵ
Parametros Nenhum   												  
ٱ


/*/
Function ReadIniCtb(lCarrega)

Local cTitCC
Local cTitItem
Local cTitClasse
Local cTamCC
Local cTamItem
Local cTamClVl
Local nHdlCusto := 0
Local nBytes:=0
Local nTamArq
Local xBuffer

DEFAULT lCarrega := .F.

If Len(aCtbIni) # 0 .And. ! lCarrega
	Return aCtbIni
Endif
aCtbIni := {}

IF !file("SIGACTB.INI")
	nHdlCusto := MSFCreate("SIGACTB.INI",0)
	IF nHdlCusto == -1
		HELP(" ",1,"CTB_ERROR")
		Final("Error F_"+str(ferror(),2)+" em SIGACTB.INI")
	Endif
	cTitCC		:= RetTitle("CTT_CUSTO",10)
	cTitItem		:= RetTitle("CTD_ITEM",10)
	cTitClasse	:= RetTitle("CTH_CLVL",10)
	cTamCC 		:= StrZero(Len(CriaVar("CTT_CUSTO")),2)
	cTamItem		:= StrZero(Len(CriaVar("CTD_ITEM")),2)
	cTamClVL		:= StrZero(Len(CriaVar("CTH_CLVL")),2)

	fWrite(nHdlCusto,"01"+cTitCC+cTamCC+"1CTT"+chr(13)+chr(10))
	fWrite(nHdlCusto,"02"+cTitItem+cTamItem+"2CTD"+chr(13)+chr(10))
	fWrite(nHdlCusto,"03"+cTitCLasse+cTamCLVL+"2CTH"+chr(13)+chr(10))
	fClose(nHdlCusto)
Endif

nHdlCusto := FOPEN("SIGACTB.INI",64)

If nHdlCusto <0
	HELP(" ",1,"CTB_ERROR")
	Final("SIGACTB.INI")
EndIf
nTamArq:=FSEEK(nHdlCusto,0,2)		// VerIfica tamanho do arquivo
FSEEK(nHdlCusto,0,0)					// Volta para inicio do arquivo

While nBytes<nTamArq

	xBuffer:=Space(20)
	FREAD(nHdlCusto,@xBuffer,20)

	AADD(	aCtbIni,SubStr(xBuffer,1,02)+" "+SubStr(xBuffer,03,10)+" "+;
			SubStr(xBuffer,13,02) + " " + SubStr(xBuffer,15,01) +" "+;
			Substr(xBuffer,16,03) )
	nBytes+=20
End

Fclose(nHdlCusto)

Return aCtbIni

/*/

Ŀ
Funo	 CtbSayApro  Autor  Pilar S. Albaladejo   Data  27/11/00 
Ĵ
Descrio Retorna a descricao do centro de custo, item ou classe de   
			 valor configurada no SIGACTB.INI          				  
Ĵ
Sintaxe	 CtbSayApro(cAlias))										  
Ĵ
Retorno	 cTexto.         											  
Ĵ
 Uso		  Generico 												  
Ĵ
Parametros ExpC1 = Alias do arquivo a ser verificado				  
ٱ


/*/
Function CtbSayApro(cAlias, cIdEntid)

Local aArea
Local cTexto     := ""
Local nPos
Local aCtbIni    := ReadIniCtb()

DEFAULT cIdEntid := ""

If Len(__CtbSayApro) > 0 .And. ( nPos := aScan(__CtbSayApro, {|x| x[1] == cAlias .And. ;
																	x[2] == cIdEntid .And. ;
																	x[3] == cEmpAnt .And. ;
																	x[4] == cFilAnt } ) ) > 0
	cTexto := __CtbSayApro[nPos, 5]
Else

	aArea      := GetArea()
	aCtbIni    := ReadIniCtb()

	If ! CtbInUse()		// Compatibilizacao com o SigaCon
		Return If(cAlias = "CTH", "", If(cAlias = "CTT", STR0003, STR0004)) //"Centro custo"###"Item Contabil"
	Endif

	If !Empty(cAlias) .And. cAlias $ "CTT/CTD/CTH"
		nPos := Ascan(aCtbIni, {|x| Substr(x,20,03) = Upper(cAlias) })
		If nPos > 0
			cTexto := Substr(aCtbIni[nPos],04,10)
		Endif
	Else
		dbSelectArea("CT0")
		dbSetOrder(1)
		//procura pelo alias na CT0
		If !Empty(cAlias)
			dbSeek(xFilial("CT0"))
			While CT0->( ! Eof()) .And. CT0_FILIAL == xFilial("CT0" )
				If CT0->CT0_ALIAS == cAlias
					cTexto := CT0->CT0_DSCRES
					Exit
				EndIf
				CT0->(dbSkip())
			EndDo
		EndIf

	 	If !Empty(cIdEntid)
			dbSelectArea("CT0")
			dbSetOrder(1)
			If dbSeek(xFilial("CT0")+cIdEntid)
				cTexto := CT0->CT0_DSCRES
			EndIf
		EndIf

	EndIf

	nPos := Ascan(aCtbIni, {|x| Substr(x,20,03) = Upper(cAlias) })
	If nPos > 0
		cTexto := Substr(aCtbIni[nPos],04,10)
	Endif

	RestArea(aArea)

	//adiciona no array __CtbSayApro cAlias, cIdEntid, cTexto - performance
	aAdd(__CtbSayApro, { cAlias, cIdEntid, cEmpAnt, cFilAnt, cTexto } )

Endif

Return cTexto

//-------------------------------------------------------------------
/*{Protheus.doc} CtbPeriodos

Retorna os periodos para a moeda.

@author Alvaro Camillo Neto

@param cMoeda  Moeda
@param dDtIni  Data Inicial
@param dDtFim  Data Final
@param lExercicio  Indica se a verificacao do periodo deve ser por exercicio
@param lZeradas  Indica se a existirem calendarios fora da data solicita .Retornara matriz com informacoes em branco


@version P12
@since   20/02/2014
@return  Nil
@obs
*/
//-------------------------------------------------------------------
FUNCTION CtbPeriodos( cMoeda, dDtIni, dDtFim, lExercicio, lZeradas, cCalend, cCriter )


LOCAL aRet		:= {}
Local aAreaPer	:= GetArea()
Local lAchouFim	:= .F.
Local cQuery

DEFAULT lExercicio := .F.
DEFAULT lZeradas   := .T.
DEFAULT cCalend    := ""
DEFAULT cCriter    := ""


If cCriter $ "2/8"					// Mdia Mensal
	dDtIni := FirstDay(dDtIni)
	dDtFim := Iif(Empty(dDtFim),LastDay(dDtIni),dDtFim)
Else
	dDtFim := Iif(Empty(dDtFim),dDtIni,dDtFim)
EndIf

// Se nao informou o calendario, exige amarracao entre Moeda e Calendario
If Empty( cCalend )
	// Localiza a moeda
	dbSelectArea("CTO")
	dbSetOrder(1)
	If MsSeek(xFilial("CTO")+cMoeda)
		dbSelectArea("CTE")
		dbSetOrder(1)
		If MsSeek(xFilial()+cMoeda)
			While !Eof() .And. CTE_FILIAL == xFilial() .And. CTE->CTE_MOEDA == cMoeda
				// Localiza os periodos para a moeda
				dbSelectArea("CTG")
				dbSetOrder(1)
				MsSeek(xFilial()+CTE->CTE_CALEND)
				While 	CTG->(!Eof()) 							.AND.;
						CTG->CTG_FILIAL == xFilial("CTG") 		.AND.;
						CTG->CTG_CALEND == CTE->CTE_CALEND

					// Se estiver dentro do periodo solicitado
					If 	If(lExercicio,  Year(CTG->CTG_DTFIM) <= Year(dDtFim) .And.;
							Year(CTG->CTG_DTINI) >= Year(dDtIni),;
							CTG->CTG_DTINI <= dDtIni .AND.;
							CTG->CTG_DTFIM >= dDtFim)
						// Adiciona os periodos na matriz de retorno
						Aadd( aRet, { 	CTG->CTG_DTINI, CTG->CTG_DTFIM,;
							CTG->CTG_EXERC, CTG->CTG_STATUS } )
						lAchouFim := .T.

						// Se o Periodo do Calendario estiver dentro do intervalo solicitado. Para atender, por exemplo, calendario com periodos diarios
					ElseIf !lExercicio .And. CTG->CTG_DTINI >= dDtIni .AND. CTG->CTG_DTINI <= dDtFim

						Aadd( aRet, { CTG->CTG_DTINI, CTG->CTG_DTFIM, CTG->CTG_EXERC, CTG->CTG_STATUS } )
						// Verificando se encontrou a data final do intervalo no calendario
						If ! lAchouFim
							lAchouFim := ( CTG->CTG_DTFIM >= dDtFim )
						EndIf

					ElseIf lZeradas
						Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
					Endif
					dbSkip()
				EndDo
				dbSelectArea("CTE")
				dbSkip()
			EndDo
			If Len(aRet) = 0
				Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })

			ElseIf !lAchouFim		//	Se nao encontrou no calendario a data final do intervalo, nao permitir continuar
				aRet := {}
				Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
			Endif
		Else
			Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
		EndIf
	Else
		Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
	EndIf
Else
	//	Se informou o calendario, NAO exige amarracao entre Moeda e Calendario. Utilizado para agrupar os
	//	valores de varias formas (Ex.: mensal, trimestral, semestral, anual, etc.) sem ter que alterar o
	//	calendario que possui a amarracao com as moedas.

	cQuery := " SELECT "
	cQuery += " CTG_FILIAL, "
	cQuery += " CTG_DTINI, "
	cQuery += " CTG_DTFIM, "
	cQuery += " CTG_CALEND, "
	cQuery += " CTG_EXERC, "
	cQuery += " CTG_STATUS, "
	cQuery += " CTG_PERIOD  "
	cQuery += " FROM " + RetSqlName("CTG")+" CTG "
	cQuery += " WHERE "
	cQuery += " CTG.D_E_L_E_T_ = ' ' "
	cQuery += " AND CTG.CTG_FILIAL = '"+xFilial("CTG")+"' "
	cQuery += " AND CTG_CALEND = '"+cCalend+"' "
	If lExercicio
		cQuery += " AND SUBSTR(CTG_DTINI,1,4) <= '"+Substr(DTOS(dDtIni),1,4)+"'  "
		cQuery += " AND SUBSTR(CTG_DTFIM,1,4) >= '"+Substr(DTOS(dDtFim),1,4)+"'  "
	Else
		cQuery += " AND CTG_DTINI <= '"+DTOS(dDtIni)+"'  "
		cQuery += " AND CTG_DTFIM >= '"+DTOS(dDtFim)+"'  "
	EndIf

	//RETIRADO PARA PERFORMANCE - ANSI NAO HA NECESSIDADE DE PASSAR PELA CHANGEQUERY
	If lExercicio .OR. ! ( Alltrim(Upper(TCGetDB())) $ "MSSQL|MSSQL7|ORACLE" )
		cQuery := ChangeQuery(cQuery)
	EndIf

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),"TMPCTG",.T.,.F.)

	If TMPCTG->(!Eof())
		While TMPCTG->(!Eof())
			Aadd( aRet, { STOD(TMPCTG->CTG_DTINI), STOD(TMPCTG->CTG_DTFIM),;
				TMPCTG->CTG_EXERC, TMPCTG->CTG_STATUS } )
			If lExercicio
				lAchouFim := .T.
			Else
				lAchouFim := ( STOD(TMPCTG->CTG_DTFIM) >= dDtFim )
			EndIf
			TMPCTG->(dbSkip())
		EndDo
		If lZeradas
			Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
		Endif
		If !lAchouFim		//	Se nao encontrou no calendario a data final do intervalo, nao permitir continuar
			aRet := {}
			Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
		Endif
	Else
		Aadd( aRet, {	CTOD("  /  /  "), CTOD("  /  /  "), Space(4), " " })
	EndIf

	dbSelectArea("TMPCTG")
	dbCloseArea()
EndIf

RestArea(aAreaPer)

RETURN aRet

/*/

Ŀ
Funo	 CtbOQMudou  Autor  Pilar S. Albaladejo 			    Data  27/11/00 
Ĵ
Descrio Verifica o que foi alterado                                            
Ĵ
Sintaxe	 CtbOQMudou(lAltDeb,lAltCrd,lAltValor,lAltTpSald,lAltMoeda,;		 	 
			 		cTipo,cTipoAnt,nValor,nValorAnt,cTpSald,cTpSaldAnt,cMoeda,		 
			 		cMoedaAnt,cOperacao)											 
Ĵ
Retorno	 Nenhum                                                      			 
Ĵ
 Uso		  Generico 												 			 
Ĵ
Parametros ExpL1 = Indica se foi feito alguma alteracao a debito				 
			  ExpL2 = Indica se foi feito alguma alteracao a credito				 
			  ExpL3 = Indica se foi feito alguma alteracao no valor				 
			  ExpL4 = Indica se foi feito alguma alteracao no tipo de saldo		 
			  ExpL5 = Indica se foi feito alguma alteracao na moeda				 
			  ExpC1 = Tipo do lancamento 											 
			  ExpC2 = Tipo do lancamento anterior									 
			  ExpN1 = Valor               											 
			  ExpN2 = Valor anterior         										 
			  ExpC3 = Tipo de Saldo           									 	 
			  ExpC4 = Tipo de Saldo anterior  									 	 
			  ExpC5 = Moeda                   										 
			  ExpC6 = Moeda anterior          										 
			  ExpC7 = Alteracao efetuada no tipo do lancamento						 
ٱ


/*/
Function CtbOQMudou(lAltDeb,lAltCrd,lAltValor,lAltTpSald,lAltMoeda,;
					cTipo,cTipoAnt,nValor,nValorAnt,cTpSald,cTpSaldAnt,cMoeda,cMoedaAnt,;
					cOperacao)

// Verifica o que ira descalcular
// Anterior = Debito / Atual = Credito				-> Descalcula Debito
//																-> Recalcula Credito
If cTipoAnt == "1" .And. cTipo == "2"
	If cOperacao == "D"			// Desgrava
		lAltDeb := .T.
	Else
		lAltCrd := .T.				// Regrava
	EndIf
EndIf
// Anterior = Debito / Atual = Partida Dobrada	-> Descalcula Debito
//																-> Recalcula Credito e Debito
If cTipoAnt == "1" .And. cTipo == "3"
	If cOperacao == "D"			// Desgrava
		lAltDeb := .T.
	Else	 							// Regrava
		lAltDeb := .T.
		lAltCrd := .T.
	EndIf
EndIf
// Anterior = Credito / Atual = Debito 			-> Descalcula Credito
//																-> Recalcula Debito
If cTipoAnt == "2" .And. cTipo == "1"
	If cOperacao == "D"			// Desgrava
		lAltCrd := .T.
	Else
		lAltDeb := .T.				// Regrava
	EndIf
EndIf
// Anterior = Credito / Atual = Partida Dobrada -> Descalcula Credito
//																-> Recalcula Debito / Credito
If cTipoAnt == "2" .And. cTipo == "3"
	If cOperacao == "D"
		lAltCrd := .T.
	Else
		lAltDeb := .T.
		lAltCrd := .T.
	EndIf
EndIf
// Anterior = Partida Dobrada / Atual = Debito	-> Descalcula os dois
//															   -> Recalcula Debito
If cTipoAnt == "3" .And. cTipo == "1"
	If cOperacao == "D"
		lAltCrd := .T.
		lAltDeb := .T.
	Else
		lAltDeb := .T.
	EndIf
EndIf
// Anterior = Partida Dobrada / Atual = Credito -> Descalcula os dois
//																-> Recalcula Credito
If cTipoAnt == "3" .And. cTipo == "2"
	If cOperacao == "D"
		lAltDeb := .T.
		lAltCrd := .T.
	Else
		lAltCrd := .T.
	EndIf
EndIf
If nValorAnt != nValor
	lAltValor := .T.
EndIf
If cTpSaldAnt != cTpSald
	lAltTpSald:= .T.
EndIf
If cMoedaAnt != cMoeda
	lAltMoeda := .T.
EndIf

Return


/*/


Ŀ
Program   CTBCBOX    Autor  Pilar S. Albaladejo    Data  22.04.01 
Ĵ
Descrio  Monta Combo Box para exibir na tela                        
Ĵ
Sintaxe   CtbCbox(cCampo)                                             
Ĵ
Retorno    Array com combo box                                        
Ĵ
Uso        Generico                                                   
Ĵ
Parametros ExpC1 = Campo que tera o Combo Box anexado                 
           ExpC2 = String contendo item a nao ser apresentado "56"    
           ExpN1 = Tamanho a ser verificado a cada item da string     
ٱ


/*/
Function CtbCbox(cCampo,cForaCombo,nLenGrava)

Local aArray1	:= {}
Local aArray2	:= {}
Local aSaveArea	:= GetArea()

Local cVar

Local nCont		:= 0

DEFAULT cForaCombo := ""
DEFAULT nLenGrava  := 1

dbSelectArea("SX3")
dbSetOrder(2)
MsSeek(cCampo)

cVar 	:= X3CBox()

If Empty(cVar)
	Return aArray2
Endif

aArray1	:= RetSx3Box(cVar,,,1)

For nCont := 1 To Len(aArray1)
	If cForaCombo <> "" .And. Left(aArray1[nCont][1], nLenGrava) $ cForaCombo
		Loop
	Endif
	AADD(aArray2,aArray1[nCont][1])
Next nCont

RestArea(aSaveArea)

Return aArray2


/*/

Ŀ
Funo    CtbPosic    Autor  Pilar S. Albaladejo    Data  04.07.01
Ĵ
Descrio Posiciona nos registros de cadastros                        
Ĵ
Sintaxe   CtbPosic(Cta,cc,Item,Clvlr)                        		  
Ĵ
Retorno   .T./.F.                                   				  
Ĵ
 Uso       Generico                                                   
Ĵ
Parametros ExpC1 = Conta                                              
           ExpC2 = Centro de Custo                                    
           ExpC3 = Item                                               
           ExpC4 = Classe de Valor                                    
ٱ


/*/
Function CtbPosic(cConta,cCusto,cItem,cCLVL)
Local bPesqCT1 := {|x| x[1]=="CT1".And. x[2]==cConta}
Local bPesqCTT := {|x| x[1]=="CTT".And. x[2]==cCusto}
Local bPesqCTD := {|x| x[1]=="CTD".And. x[2]==cItem}
Local bPesqCTH := {|x| x[1]=="CTH".And. x[2]==cCLVL}
Local nPos := 0
Local lCache := CtbCache(4)
// Plano de Contas
If cConta <> Nil .And. ! Empty(cConta)
	dbSelectArea("CT1")
	If ! lCache
		dbSetOrder(1)
		MsSeek(xFilial("CT1")+cConta)
	Else
		If (nPos := Ascan(__CtbPosic, bPesqCT1)) == 0
			dbSetOrder(1)
			If MsSeek(xFilial("CT1")+cConta)
			   aAdd(__CtbPosic, { "CT1", cConta, Recno() } )
			Else
			   aAdd(__CtbPosic, { "CT1", cConta, 0 } )
			EndIf
		Else
			If lCache .And. __CtbPosic[nPos, 3] > 0
				MsGoto(__CtbPosic[nPos, 3])
			EndIf
		EndIf
	EndIf
Endif

If cCusto <> Nil .And. ! Empty(cCusto)
	// Centro de Custo
	dbSelectArea("CTT")
	If ! lCache
		dbSetOrder(1)
		MsSeek(xFilial("CTT")+cCusto)
	Else
		If (nPos := Ascan(__CtbPosic, bPesqCTT)) == 0
			dbSetOrder(1)
			If MsSeek(xFilial("CTT")+cCusto)
			   aAdd(__CtbPosic, { "CTT", cCusto, Recno() } )
			Else
			   aAdd(__CtbPosic, { "CTT", cCusto, 0 } )
			EndIf
		Else
			If __CtbPosic[nPos, 3] > 0
				MsGoto(__CtbPosic[nPos, 3])
			EndIf
		EndIf
	EndIf
Endif
// Item Contabil
If cItem <> Nil .And. ! Empty(cItem)
	dbSelectArea("CTD")

	If ! lCache
		dbSetOrder(1)
		MsSeek(xFilial("CTD")+cItem)
	Else
		If (nPos := Ascan(__CtbPosic, bPesqCTD)) == 0
			dbSetOrder(1)
			If MsSeek(xFilial("CTD")+cItem)
			   aAdd(__CtbPosic, { "CTD", cItem, Recno() } )
			Else
			   aAdd(__CtbPosic, { "CTD", cItem, 0 } )
			EndIf
		Else
			If __CtbPosic[nPos, 3] > 0
				MsGoto(__CtbPosic[nPos, 3])
			EndIf
		EndIf
	EndIf
Endif
// Classe de Valor
If cCLVL <> Nil	.And. ! Empty(cClVl)
	dbSelectArea("CTH")

	If ! lCache
		dbSetOrder(1)
		MsSeek(xFilial("CTH")+cCLVL)
	Else
		If (nPos := Ascan(__CtbPosic, bPesqCTH)) == 0
			dbSetOrder(1)
			If MsSeek(xFilial("CTH")+cCLVL)
			   aAdd(__CtbPosic, { "CTH", cCLVL, Recno() } )
			Else
			   aAdd(__CtbPosic, { "CTH", cCLVL, 0 } )
			EndIf
		Else
			If __CtbPosic[nPos, 3] > 0
				MsGoto(__CtbPosic[nPos, 3])
			EndIf
		EndIf
	EndIf
Endif

Return

/*/

Ŀ
Funo     CtbCtsM       Autor  Wagner Mobile Costa	 Data  25/10/01 
Ĵ
Descrio  Funcao para uso em consulta SXB para  apresentar registros  do 
           plano gerencial atual                                          
Ĵ
Uso        Ctba160                                                        
ٱ


/*/

Function CtbCtsM(lFilial)

DEFAULT lFilial := .T.

Return If(lFilial, xFilial("CTS"), "") + cCts_CodPla


/*


ͻ
Funcao    GrafSavBmp  AutorClaudio D. de Souza  Data   30/08/01   
͹
Desc.      Salvar o grafico em BMP                                    
           Parametro: oGrafic -> Objeto grafico                       
͹
Uso        Administrativo                                             
ͼ


*/
Function GrafSavBmp( oGraphic )

Local cBmpName, cTmp
Local cWhereToSave := "\" // Somente gravar abaixo do rootpath do servidor
Local cRaizServer // Onde sera criado o arquivo da imagem

cBmpName := cGetFile(STR0005 + FunName() + ".BMP", STR0006 ) //"Arquivos BMP | "###"Selecione arquivo .BMP"

If Empty(cBmpName)
	Return
Endif

If Rat("\", cBmpName) > 0
	cWhereToSave 	:= Subs(cBmpName, 1, Rat("\", cBmpName))
	cBmpName	    := Subs(cBmpName, Rat("\", cBmpName) + 1)
Endif

If At(":", cWhereToSave) > 0
	cTmp := CriaTrab(, .F.) + ".BMP"
	cRaizServer := If(issrvunix(), "/", "\")
	If oGraphic:SaveToBMP( cTmp , cRaizServer )
		__CopyFile(cRaizServer + cTmp, cWhereToSave + cBmpName)
		Ferase(cRaizServer + cTmp)
		Help(" ",1,"CT5CRIA3",,STR0007+cBmpName+STR0008,1,0) //"Arquivo: "###" gerado com sucesso"
	Else
		Help(" ",1,"CT5CRIA2",,STR0009,1,0)//"Nao foi possivel gerar o arquivo bitmap do grafico"
	Endif
Else
	If oGraphic:SaveToBMP( cBmpName , cWhereToSave )
		Help(" ",1,"CT5CRIA4",,STR0007+cBmpName+STR0008,1,0)//"Arquivo: "###" gerado com sucesso"
	Else
		Help(" ",1,"CT5CRIA5",,STR0009,1,0)//"Nao foi possivel gerar o arquivo bitmap do grafico"
	Endif
Endif

Return Nil

/*/


Ŀ
Program    ConsDadGraf  Autor  Wagner Mobile Costa    Data  10.11.01 
Ĵ
Descrio  Monta Browse de consulta sobre array utilizado para graficos  
ٱ


/*/
Function ConsDadGraf(aDados)
Local aTit := {}, aLenCol := {}, nLenTot := 0
Local oView, oDlg, aView := {}, nView
Local nX	:= 0

For nx := 1 to Len(aDados[1])
	Aadd(aTit, aDados[1][nX])
	If Len(aDados[1][nX]) > Len(aDados[2][nX])
		Aadd(aLenCol, GetTextWidth(0,Replicate("B", Len(aDados[2][nX]))))
	Else
		Aadd(aLenCol, GetTextWidth(0,Replicate("B", Len(aDados[1][nX]))))
	Endif
	nLenTot += aLenCol[Len(aLenCol)]
Next

nLenTot := (370*nLenTot)/130

DEFINE MSDIALOG oDlg FROM 0,0 TO 285,Min(nLenTot,oMainWnd:nRight-oMainWnd:nLeft - 10)  PIXEL TITLE STR0010 //"Consulta dados do grafico"

oView	:= TWBrowse():New( 1,1,	((oDlg:nRight - oDlg:nLeft) / 2) - 5,;
		 									 (oDlg:nBottom / 2) - 15,,;
			aTit,aLenCol,oDlg,,,,,,,,,,,,.F.,,.T.,,.F.,,,)

For nView := 2 To Len(aDados)
	Aadd(aView, aDados[nView])
Next

oView:SetArray(aView)
oView:bLine := { || aView[oView:nAT]}

ACTIVATE MSDIALOG oDlg CENTER

Return

/*/

Ŀ
Funo    CtQualSaldo Autor  Wagner Mobile Costa    Data  19.03.2002		
Ĵ
Descrio  Checa qual registro deve ser considerado como saldo atual  			
Ĵ
Sintaxe    CtQualSaldo(lImpAntLP, lNaoAchei, cAlias)                     	    
Ĵ
 Uso       SigaCtb                                                   			
Ĵ
Parametros ExpL1 = Imprime posicao anterior L/P                      		    
           ExpL2 = Variavel que indica se a data encontrada nao for exata	    
           ExpB1 = Bloco de codigo de checagem se foi encontrado     		    
           ExpC1 = Alias para checagem                               		    
ٱ


/*/

Function CtQualSaldo(lImpAntLP, lNaoAchei, bCondicao, cAlias)

DEFAULT cAlias := Alias()

// Procuro sempre o primeiro registro, caso encontro um registro de zeramento
// e quero a posicao anterior de lucros e perdas, volto

If Eval(bCondicao) .And. &(cAlias + "_LP") = "S" .And. ! lImpAntLP
	DbSkip()
	If !Eval(bCondicao) .Or. ! &(cAlias + "_LP") = "Z"
		DbSkip(-1)
	Endif
ElseIf Eval(bCondicao) .And. &(cAlias + "_LP") = "Z" .And. lImpAntLP
	DbSkip(-1)
ElseIf (! Eval(bCondicao) .Or. Eof())
	DbSkip(-1)
	If lImpAntLP .And. &(cAlias + "_LP") = "Z"
		DbSkip(-1)
	Endif
	lNaoAchei := .T.
Endif

Return .T.

/*/

Ŀ
Funo    CtbTitSaldo  Autor  Wagner Mobile Costa   Data  10.07.2002		
Ĵ
Descrio  Funcao de retorno do tipo de saldo para apresentacao nos balancetes	
Ĵ
Sintaxe    CtbTitSaldo(cTpSald)                                         	  	
Ĵ
 Uso       SigaCtb                                                   			
Ĵ
Parametros cTpSald = Tipo de saldo selecionado                            		
ٱ


/*/

Function CtbTitSaldo(cTpSald)

Local cTitulo := ""
Default cTpSald := ""

If cTpSald == "0" .Or. cTpSald > "1"
	cTitulo += " (" + Tabela("SL", cTpSald, .F.) + ")"
Endif

Return cTitulo

/*/

Ŀ
Funao     CtbImpReg     Autor  Wagner Mobile Costa	 Data  12/03/02 
Ĵ
Descrio  Importa registros gerados para base do dicionario              
Ĵ
Sintaxe   CtbImpReg( cAlias, aRegistros )                                 
Ĵ
Retorno   Nenhum                                                      	  
Ĵ
 Uso		  CtbaUpd                                                    	  
Ĵ
Parametros ExpC1 = Alias para importacao da matriz                    	  
           ExpA1 = Array na mesma ordem dos campos (gerado p/Delimitador) 
ٱ


/*/
Function CtbImpReg(cAlias, aRegistros)

Local aEstrutura, nRegs, nCpos
Local lAppend, cPath
Local lRet	:= .T.

DbSelectArea(cAlias)

If cAlias = "SIX"
	aEstrutura := { "INDICE", "ORDEM", "CHAVE", "DESCRICAO", "DESCSPA", "DESCENG",;
					"PROPRI","F3", "NICKNAME" }
ElseIf cAlias = "SX3"
	aEstrutura := {  "X3_ARQUIVO", "X3_ORDEM", "X3_CAMPO", "X3_TIPO", "X3_TAMANHO",;
	  				 "X3_DECIMAL", "X3_TITULO", "X3_TITSPA", "X3_TITENG", "X3_DESCRIC",;
	  				 "X3_DESCSPA", "X3_DESCENG", "X3_PICTURE", "X3_VALID", "X3_USADO",;
	  				 "X3_RELACAO", "X3_F3", "X3_NIVEL", "X3_RESERV", "X3_CHECK",;
	  				 "X3_TRIGGER", "X3_PROPRI", "X3_BROWSE", "X3_VISUAL", "X3_CONTEXT",;
	  				 "X3_OBRIGAT", "X3_VLDUSER", "X3_CBOX", "X3_CBOXSPA", "X3_CBOXENG",;
	  				 "X3_PICTVAR", "X3_WHEN", "X3_INIBRW", "X3_GRPSXG", "X3_FOLDER" }
	DbSetOrder(2)		// Ordem por campo
Else
	lRet := .F.
	Help(" ",1,"CtbImpReg",,"Tabela de dicionrio de dados no suportada pela funo.",1,0) //"Tabela de dicionrio de dados no suportada pela funo."
Endif

If lRet
	For nRegs := 1 To Len(aRegistros)
		lAppend := .T.
		If cAlias = "SIX"
			lAppend := ! DbSeek(aRegistros[nRegs][1] + aRegistros[nRegs][2])
			If lAppend .And. Select(aRegistros[nRegs][1]) > 0
				(aRegistros[nRegs][1])->(DbCloseArea())
			Endif
		ElseIf 	cAlias = "SX3"
			lAppend := ! DbSeek(aRegistros[nRegs][3])
		Endif

		If lAppend
			DbAppend()
			For nCpos := 1 To Len(aEstrutura)
				Replace &(aEstrutura[nCpos]) With aRegistros[nRegs][nCpos]
			Next
		Endif
	Next
EndIf

Return lRet


/*/


Ŀ
 Funao    Ctbr380Val Autor  Wagner Mobile Costa    Data  08/05/02 
Ĵ
 Descrio  Calcula o valor da variacao monetaria da data-base (CT2)   
Ĵ
 Uso        CTBR380                                                    
ٱ


/*/

Function Ctbr380Val(lPlGer, aContas)

Local lDebito 	:= .F., cCriter, nTaxa := 0, nSal1C, aAnaCta := {}, nAnaCta := 1

DEFAULT lPlGer 	:= .F.
DEFAULT aContas	:= { cArqTmp->CONTA }

// Se for plano gerencial, devera eleger somente contas que tenham variacao monetaria

If ! lPlGer .And. Empty(CT1->CT1_CTAVM) .And. cArqTmp->TIPOCONTA = "2"
	DbDelete()
ElseIf cArqTmp->TIPOCONTA = "2"
	If mv_par20 = 1
		If ValType(aContas[1]) = "A"
			For nAnaCta := 1 To Len(aContas)
				CT1->(DbSeek(xFilial() + aContas[nAnaCta][1]))
				While 	CT1->CT1_FILIAL = xFilial() .And.;
						CT1->CT1_CONTA <= aContas[nAnaCta][2] .And. ! CT1->(Eof())
					If CT1->CT1_CLASSE = "2"
						Aadd(aAnaCta, CT1->CT1_CONTA)
					Endif
					CT1->(DbSkip())
				EndDo
			Next
		Else
			aAnaCta := Aclone(aContas)
		Endif
		For nAnaCta := 1 To Len(aAnaCta)
			CT2->(DbSetOrder(2))
			If CT2->(DbSeek(xFilial() + aAnaCta[nAnaCta] + Dtos(mv_par01)))
				While 	CT2->CT2_DEBITO = aAnaCta[nAnaCta] 	.And.;
						CT2->CT2_DATA = mv_par01 			.And. ! CT2->(Eof())
					If CT2->CT2_MOEDLC = mv_par07 .And. CT2->CT2_ROTINA = "CTBA380"
						Replace COLUNA_1 With CT2->CT2_VALOR * -1
						lDebito := .T.
					Endif
					CT2->(DbSkip())
				EndDo
			Endif
			CT2->(DbSetOrder(3))
			If ! lDebito .And. CT2->(DbSeek(xFilial() + aAnaCta[nAnaCta] + Dtos(mv_par01)))
				While 	CT2->CT2_CREDIT = aAnaCta[nAnaCta] 	.And.;
						CT2->CT2_DATA = mv_par01 			.And. ! CT2->(Eof())
					If CT2->CT2_MOEDLC = mv_par07 .And. CT2->CT2_ROTINA = "CTBA380"
						Replace COLUNA_1 With CT2->CT2_VALOR
						lDebito := .T.
					Endif
					CT2->(DbSkip())
				EndDo
			Endif
		Next
		CT2->(DbSetOrder(1))
	Else
		If mv_par21 = 2
			If cArqTmp->NORMAL = "1"
				cCriter := &("CT1->CT1_CVD" + mv_par07)
			Else
				cCriter := &("CT1->CT1_CVC" + mv_par07)
			Endif
			If cCriter = "1" .And. CTP->(DbSeek(xFilial()+DTOS(mv_par01)+mv_par07))
				nTaxa := CTP->CTP_TAXA
			ElseIf cCriter = "2"
				nTaxa := aMedias[Val(mv_par07)]
			ElseIf cCriter = "3" .And. CTP->(DbSeek(xFilial()+DTOS(LastDay(mv_par01))+mv_par07))
				nTaxa := CTP->CTP_TAXA
			Endif
		Else
			If CTO->CTO_MOEDA # mv_par07	// Garanto que a moeda esteja posicionada
				CTO->(DbSeek(xFilial() + mv_par07))
			Endif
			cCriter := CTO->CTO_CRITER
			If cCriter = "1" .And. CTP->(DbSeek(xFilial()+DTOS(mv_par01)+mv_par07))
				nTaxa := CTP->CTP_TAXA
			ElseIf cCriter = "2"
				nTaxa := aMedias[Val(mv_par07)]
			ElseIf cCriter = "3" .And. CTP->(DbSeek(xFilial()+DTOS(LastDay(mv_par01))+mv_par07))
				nTaxa := CTP->CTP_TAXA
			ElseIf cCriter = "4"
				nTaxa := CTO->CTO_TXINF
			Endif
		Endif

		nSal1C := NoRound(MOVIMENTO1 / nTaxa, 2)
		If 	nTaxa > 0 .And. nSal1C <> 0 .And. nSal1C <> MOVIMENTO2
			Replace COLUNA_1 With MOVIMENTO2 - nSal1C
		Endif
	Endif

	If COLUNA_1 = 0 .And. mv_par06 = 2
		DbDelete()
	Else
		Replace COLUNA_2 	With MOVIMENTO2
		Replace MOVIMENTO2  With MOVIMENTO2 - COLUNA_1
		Replace VARIACAO 	With Round(NoRound((Abs(COLUNA_1) / Abs(MOVIMENTO2)) * 100, 2), 2)
	Endif
ElseIf cArqTmp->TIPOCONTA = "1"
	Replace VARIACAO 	With Round(NoRound((Abs(COLUNA_1) / Abs(MOVIMENTO2)) * 100, 2), 2)
Endif

Return

/*/

Ŀ
Funo    CtbCCSup   Autor  Simone Mie Sato        Data  02.10.03 
Ĵ
Descrio  Gera Codigo do Centro de Custo Superior                    
Ĵ
Sintaxe   CtbCCSup(cCodigo)                                           
Ĵ
Retorno   cCod                                                        
Ĵ
 Uso       Generico                                                   
Ĵ
Parametros ExpC1 = Codigo do Centro de Custo                          
ٱ


/*/
Function CtbCCSup(cCodigo)

Local aAmbSave 	:= { Alias(), Indexord(), Recno() }
Local nTamCC	:= Len(CriaVar("CTT_CUSTO"))
Local aAmbCTT  := { CTT->(IndexOrd()) , CTT->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CTT") ; dbSetOrder(1)

//Ŀ
// PONTO DE ENTRADA CTBCCSUP                            
// Criado para gerar c.c.  superior caso nao            
// siga a regra padrao do Sistema.                      
// Recebe em PARAMIXB o centro de custo atual.          
//
If ExistBlock("CTBCCSUP")
	cCod := ExecBlock("CTBCCSUP",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),nTamCC)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CTT->CTT_CUSTO
			Exit
		EndIf
	Next
EndIf

CTT->(DbSetOrder(aAmbCTT[1])) ; CTT->(DbGoto(aAmbCTT[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod

/*/

Ŀ
Funo    CtbItemSup Autor  Simone Mie Sato        Data  03.10.03 
Ĵ
Descrio  Gera Codigo do Item Contabil Superior                      
Ĵ
Sintaxe   CtbItemSup(cCodigo)                                         
Ĵ
Retorno   cCod                                                        
Ĵ
 Uso       Generico                                                   
Ĵ
Parametros ExpC1 = Codigo do Item Contabil                            
ٱ


/*/
Function CtbItemSup(cCodigo)

Local aAmbSave 	:= { Alias(), Indexord(), Recno() }
Local nTamItem	:= Len(CriaVar("CTD_ITEM"))
Local aAmbCTD	:= { CTD->(IndexOrd()) , CTD->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CTD") ; dbSetOrder(1)

//Ŀ
// PONTO DE ENTRADA CTBITSUP                            
// Criado para gerar item  superior caso nao            
// siga a regra padrao do Sistema.                      
// Recebe em PARAMIXB o item contabil  atual.           
//
If ExistBlock("CTBITSUP")
	cCod := ExecBlock("CTBITSUP",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),nTamItem)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CTD->CTD_ITEM
			Exit
		EndIf
	Next
EndIf

CTD->(DbSetOrder(aAmbCTD[1])) ; CTD->(DbGoto(aAmbCTD[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod


/*/

Ŀ
Funo    CtbClVlSup Autor  Simone Mie Sato        Data  03.10.03 
Ĵ
Descrio  Gera Codigo da Cl.Valor Superior                           
Ĵ
Sintaxe   CtbClVlSup(cCodigo)                                         
Ĵ
Retorno   cCod                                                        
Ĵ
 Uso       Generico                                                   
Ĵ
Parametros ExpC1 = Codigo da Classe de Valor                          
ٱ


/*/
Function CtbClVlSup(cCodigo)

Local aAmbSave 	:= { Alias(), Indexord(), Recno() }
Local nTamClVl	:= Len(CriaVar("CTH_CLVL"))
Local aAmbCTH	:= { CTH->(IndexOrd()) , CTH->(Recno()) }
Local cCod , nCont

cCodigo			:= Alltrim(cCodigo)

dbSelectArea("CTH") ; dbSetOrder(1)

//Ŀ
// PONTO DE ENTRADA CTBCVSUP                            
// Criado para gerar Cl.Vlr. superior caso nao          
// siga a regra padrao do Sistema.                      
// Recebe em PARAMIXB a cl.Valor Atual.                 
//
If ExistBlock("CTBCVSUP")
	cCod := ExecBlock("CTBCVSUP",.F.,.F.,cCodigo)
Else
	For nCont := 1 to Len(cCodigo)
		cCod  := padr(Substr(cCodigo,1,Len(cCodigo)-nCont),nTamClVl)
		If MsSeek(xFilial()+cCod,.f.)
			cCod := CTH->CTH_CLVL
			Exit
		EndIf
	Next
EndIf

CTH->(DbSetOrder(aAmbCTH[1])) ; CTH->(DbGoto(aAmbCTH[2]))
DbSelectArea(aAmbSave[1]) ; DbSetOrder(aAmbSave[2]) ; DbGoto(aAmbSave[3])

Return cCod

/*


ͻ
Programa  CtbRelDig Autor  Simone Mie Sato      Data   30/01/04   
͹
Desc.     Retorna ate qual digito da entidade contabil sera impresso  
          no Relatorio.                                               
͹
Parametro1 cSegAte   = Ate qual segm.da masc. contab.sera considerado.
         2 cMascara	 = Qual a mascara a ser considerada.          	  
ͼ


*/
Function CtbRelDig(cSegAte,cMascara)

Local aSaveArea	:= GetArea()
Local nSegAte	:= 0
Local nCont		:= 0
Local nDigitAte	:= 0

nSegAte	:= Val(cSegAte) *2
For nCont := 1 to nSegAte STEP 2
	nDigitAte += Val(Subs(cMascara,nCont,2))
Next nCont


RestArea(aSaveARea)

Return(nDigitAte)

/*/

Ŀ
Funo    CtbNivCta    Autor  Simone Mie Sato       Data  24.03.2005		
Ĵ
Descrio  Retorna o nivel da conta                                             
Ĵ
Sintaxe    CtbNivCta()                                                          
Ĵ
 Uso       SigaCtb                                                   			
Ĵ
Parametros cConta 	   = Codigo da conta                            		   	
ٱ


/*/
Function CtbNivCta(cConta)

Local aSaveArea	:= GetArea()

Local nNivel	:= 1
Local nRecno	:= CT1->(Recno())

dbSelectArea("CT1")
dbSetOrder(1)
If MsSeek(xFilial()+cConta)
	While !Eof() .And. CT1->CT1_FILIAL == xFilial() .And. !Empty(CT1->CT1_CTASUP)
		If MsSeek(xFilial()+CT1->CT1_CTASUP)
	    	nNivel++
 		Else
 			dbSkip()
		EndIf
	End
EndIf

dbSelectArea("CT1")
dbGoto(nRecno)

RestArea(aSaveArea)


Return(nNivel)

/*/

Ŀ
Funo    CtbTmpSint   Autor  Simone Mie Sato       Data  28.03.2005		
Ĵ
Descrio  Cria arquivo temporario com contas analiticas e sinteticas.          
Ĵ
Sintaxe    CtbTmpSint()                                                         
Ĵ
 Uso       SigaCtb                                                   			
Ĵ
Parametros                                    	                     		   	
ٱ


/*/
Function CtbTmpSint(dDataIni,dDataFim)

Local aSaveArea	:= Getarea()
Local aSetOfBook:= {"","",0,"","","","","",1,""}

Local oMeter
Local oText
Local oDlg

Local lEnd := .F.

Local cArqTmp

Local nTamCta	:= TAMSX3("CT1_CONTA")

//Ŀ
// Monta Arquivo Temporario para Impressao							  
//
MsgMeter({|	oMeter, oText, oDlg, lEnd | ;
				CTGerPlan(oMeter, oText, oDlg, @lEnd,@cArqTmp,;
				dDataIni,dDataFim,"CT7","","","ZZZZZZZZZZZZZZZZZZZZ",,,,,,,'01',;
				"1",aSetOfBook,,,,,,,,,.F.,,1,.T.,,,,,,,,,,,,,,.T.,,,,)},;
				(STR0011),;  //"Selecionando Registros..."
				(STR0012))	//"Gerando arquivo temporario..."

dbSelectArea("cArqTmp")
dbCloseArea()
dbUseArea( .T.,, cArqTmp, "AT7", .F., .F. )

RestArea(aSaveArea)

Return

/*/

Ŀ
Funo    CtbTmpClos   Autor  Simone Mie Sato       Data  28.03.2005		
Ĵ
Descrio  Fecha arquivo temporario.                                            
Ĵ
Sintaxe    CtbTmpClos()                                                         
Ĵ
 Uso       SigaCtb                                                   			
Ĵ
Parametros                                    	                     		   	
ٱ


/*/
Function CtbTmpClos(cArqTmp)

Local aSaveArea	:= GetArea()

dbSelectArea("AT7")
dbCloseArea()

If Select("AT7") == 0
	FErase(cArqTmp+GetDBExtension())
	FErase(cArqTmp+OrdBagExt())
EndIF


RestArea(aSaveArea)

Return
/*


ͻ
Programa  RETRECNOLPAutor  Marcos S. Lobo       Data   01/12/06   
͹
Desc.     Retorna os recno do registro de origem de acordo com o lan.
          padrao.                                                     
͹
Uso        AP                                                         
ͼ


*/
Function RetRecnoLP(cPadrao,cTabOrigem,cAliasPos)

Local nRecOrigem := 0
Local nPosORISE2 := 0 		/// POSICAO ORIGINAL DO SE2 NO CASO DE LP DE RATEIO FIN
Local nPosORISE5 := 0		///POSICAO ORIGINAL DO SE2 NO CASO DE LP DE RATEIO FIN
Local lTotalizador := .F.  // Usado quando a contabilizacao refere-se a um conjunto de registros

DEFAULT cTabOrigem := ""
DEFAULT cAliasPos  := ""

If cTabOrigem <> Nil
	cTabOrigem := UPPER(ALLTRIM(cTabOrigem))
EndIf

If Empty(cPadrao) .or. ValType(cPadrao) <> "C"
	UserException("Invalid parameter 1 - RetRecnoLP()")
	Return(0)
EndIf

If ValType(cTabOrigem) <> "C"
	UserException("Invalid parameter 2 - RetRecnoLP("+cPadrao+",)")
	Return(0)
EndIf

DO CASE
CASE 	 cPadrao == "500";	///	Incluso de Contas a Receber				FIN	FINA040/FINA370	SE1	E1_LA
	.or. cPadrao == "501";	///	Incluso de Recebimento Antecipado (RA)		FIN	FINA040/FINA370	SE1	E1_LA
	.or. cPadrao == "502";	///	Excluso de Recebimento Antecipado			FIN	FINA040	SE1	E1_LA
	.or. cPadrao == "503";	///	Substituio de Provisrios					FIN	FINA040	SE1	E1_LA
	.or. cPadrao == "504";	///	Gerao de Ttulo Receber por Desdobramento	FIN	FINA040/FINA370	SE1	E1_LA
	.or. cPadrao == "505";	///	Excluso de Contas a Receber				FIN	FINA040	SE1	E1_LA
	.or. cPadrao == "529"	///	Excluso de ttulo gerado via desdobramento	FIN	FINA040	SE1	E1_LA

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

	If (cTabOrigem)->(Eof()) .and. SEV->(!Eof())	/// VERIFICA SE  RATEIO MULT.NATUREZA SEM RAT.CC (CONTAB PELO 510)
		cTabOrigem := "SEV"
	EndIf

CASE 	 cPadrao == "506";	///	Rateio Centro de Custo Mltipla Natureza Contas a Receber				FIN	FINA040	SE1	E1_LA
	.or. cPadrao == "507";	///	Cancelamento Rateio Centro de Custo Mltipla Natureza Conntas a Receber	FIN	FINA040	SE1	E1_LA
	.or. cPadrao == "536";	// Rateio por C.Custo de MultiNat C.Receber na Baixa
	.or. cPadrao == "539"	// Estorno do rateio C.Custo de MultiMat CR na Baixa

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		If SEV->EV_RATEICC == "1"	/// SE FOR MULTIPLA NATUREZA POR C.CUSTO
			cTabOrigem := "SEZ"	/// MULT.NATUREZA - FLAGS SEV ( funo CTBApLAMN() ao apagar )
		Else						/// SE FOR MULTIPLA NATUREZA
			cTabOrigem := "SEV"	/// MULT.NATUREZA SE BASEIA NO TTULO - FLAGS SEZ ( funo CTBApLAMN() ao apagar )
		EndIf
	EndIf

CASE cPadrao == "508";	///	Rateio Centro de Custo Mltipla Natureza Contas a Pagar						FIN	FINA050	SE2	E2_LA
	.or. cPadrao == "509";	///	Cancelamento Rateio Centro de Custo Mltipla Natureza Contas a Pagar	FIN	FINA050	SE2	E2_LA
	.or. cPadrao == "537";	// Rateio por C.Custo de MultiNat C.Pagar na Baixa
	.or. cPadrao == "538"	// Estorno do rateio C.Custo de MultiMat CP na Baixa

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		If SEV->EV_RATEICC == "1"	/// SE FOR MULTIPLA NATUREZA POR C.CUSTO
			cTabOrigem := "SEZ"	/// MULT.NATUREZA - FLAGS SEV ( funo CTBApLAMN() ao apagar )
		Else						/// SE FOR MULTIPLA NATUREZA
			cTabOrigem := "SEV"	/// MULT.NATUREZA SE BASEIA NO TTULO - FLAGS SEZ ( funo CTBApLAMN() ao apagar )
		EndIf
	EndIf

CASE 	 cPadrao == "510";	///	Incluso de Contas a Pagar						FIN	FINA050/FINA370	SE2	E2_LA
	.or. cPadrao == "515";	///	Excluso de Contas a Pagar						FIN	FINA050	SE2	E2_LA
	.or. cPadrao == "577";	///	Gerao de Ttulo a Pagar via desdobramento		FIN	FINA050/FINA370
	.or. cPadrao == "578";	///	Excluso de Tt. a Pg gerado via desdobramento	FIN	FINA050
	.or. cPadrao == "513";	///	Incluso de Pagamento Antecipado (PA)			FIN	FINA050/FINA370	SE2	E2_LA
	.or. cPadrao == "514";	///	Excluso de Pagamento Antecipado (PA)			FIN	FINA050	SE2	E2_LA
	.or. cPadrao == "533";	///	Substituio de Provisrios						FIN	FINA050
	.or. cPadrao == "587";	///	Faturas a Pagar									FIN	FINA290
 	.or. cPadrao == "593"	///	Cancelamento Faturas a Pagar					FIN	FINA290

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO

		//--------------------------------------------------------------
		// Define se a Contabilizao do LP513 ocorrer pelo Ttulo(SE2)
		// ou Mov.Bancario(SE5) do Pagamento Antecipado
		//--------------------------------------------------------------
		If cPadrao == "513" .And. SuperGetMv("MV_CTMOVPA",.T.,"1") == "2"
			cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
		Else
			cTabOrigem := "SE2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
		EndIf

	EndIf

	If (cTabOrigem)->(Eof()) .and. SEV->(!Eof())	/// VERIFICA SE  RATEIO MULT.NATUREZA SEM RAT.CC (CONTAB PELO 510)
		cTabOrigem := "SEV"
	EndIf

CASE 	cPadrao == "511";	///	Incluso de Contas a Pagar com Rateio Simples	FIN	FINA050/FINA370	SE2	E2_LA
	.or. cPadrao == "512";	///	Excluso de Contas a Pagar com Rateio Simples	FIN	FINA050	SE2	E2_LA

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

	If SE2->(Eof()) .and. ValType(STRLCTPAD) == "N"
		nPosORISE2 := SE2->(Recno())
		SE2->(MsGoTo(STRLCTPAD))				/// POSICIONA PARA O RASTREAMENTO CASO ESTEJA EM EOF.
	EndIf

CASE 	 cPadrao == "516";	///	Incluso Movimento Bancrio Pagar com Rateio				FIN	FINA100/FINA370	SE5	E5_LA
	.or. cPadrao == "517";	///	Incluso Movimento Bancrio Receber com Rateio				FIN	FINA100/FINA370	SE5	E5_LA
	.or. cPadrao == "557";	///	Cancelamento de Movimento Bancrio Pagar com Rateio			FIN	FINA100
	.or. cPadrao == "558"	///	Cancelamento de Movimento Bancrio Receber com Rateio		FIN	FINA100

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

	If SE5->(Eof()) .and. ValType(STRLCTPAD) == "N"
		nPosORISE5 := SE5->(Recno())
		SE5->(MsGoTo(STRLCTPAD))				/// POSICIONA PARA O RASTREAMENTO CASO ESTEJA EM EOF.
	EndIf

CASE 	 cPadrao == "560";	///	Transferncia Financeira/Bancria - Sada do Banco Origem	FIN	FINA100/FINA370
	.or. cPadrao == "561";	///	Transferncia Financeira/Bancria - Entrada Banco Destino	FIN	FINA100/FINA370
	.or. cPadrao == "562";	///	Movimento Bancrio Pagar									FIN	FINA100/FINA370
	.or. cPadrao == "563";	///	Movimento Bancrio Receber									FIN	FINA100/FINA370
	.or. cPadrao == "564";	///	Cancelamento Movimento Bancrio Pagar						FIN	FINA100
	.or. cPadrao == "565"	///	Cancelamento Movimento Bancrio Receber	FIN	FINA100

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "518";	///	Baixa por Vendor					FIN	FINA080	SE2	E2_LA
	.or. cPadrao == "519"	///	Cancelamento de Baixa por Vendor	FIN	FINA080	SE2	E2_LA

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

	If (cTabOrigem)->(Eof()) .and. SEV->(!Eof())	/// VERIFICA SE  RATEIO MULT.NATUREZA SEM RAT.CC (CONTAB PELO 510)
		cTabOrigem := "SEV"
	EndIf

CASE 	 cPadrao == "520";	///	Baixas a Receber Carteira						FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "521";	///	Baixas a Receber Cobrana Simples				FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "522";	///	Baixas a Receber Cobrana Descontada			FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "523";	///	Baixas a Receber Cobrana Caucionada			FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "524";	///	Baixas a Receber Cobrana Vinculada				FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "525";	///	Baixas a Receber Cobrana Advogado				FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "526";	///	Baixas a Receber Cobrana Judicial				FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "527";	///	Cancelamento de Baixas a Receber				FIN	FINA060/FINA370	SE5	E5_LA
	.or. cPadrao == "528"	///	Baixas a Receber Cobrana Caucionada Descontada	FIN	FINA060/FINA370	SE5	E5_LA

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

	If (cTabOrigem)->(Eof()) .and. SEV->(!Eof())	/// VERIFICA SE  RATEIO MULT.NATUREZA SEM RAT.CC (CONTAB PELO 510)
		cTabOrigem := "SEV"
	EndIf

CASE 	 cPadrao == "530";	///	Baixa Manual Contas a Pagar / Retorno Comunicao Bancria Pagar	FIN	FINA080/FINA370	SE5	E5_LA
	.or. cPadrao == "531";	///	Cancelamento Baixas a Pagar	FIN	FINA080/FINA370	SE5	E5_LA
	.or. cPadrao == "532"	///	Baixas por Border de Pagamento	FIN	FINA090/FINA370

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

	If (cTabOrigem)->(Eof()) .and. SEV->(!Eof())	/// VERIFICA SE  RATEIO MULT.NATUREZA SEM RAT.CC (CONTAB PELO 510)
		cTabOrigem := "SEV"
	EndIf

CASE 	 cPadrao == "540";	///	Transferncia para Carteira	FIN	FINA060/FINA370

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "541";	///	Transferncia para Cobrana Simples		FIN	FIN
	.or. cPadrao == "541";	///	Transferncia para Cobrana Simples	FIN	FINA110
	.or. cPadrao == "542";	///	Transferncia para Cobrana Descontada	FIN	FINA110
	.or. cPadrao == "543";	///	Transferncia para Cobrana Caucionada	FIN	FINA110
	.or. cPadrao == "544";	///	Transferncia para Cobrana Vinculada	FIN	FINA110
	.or. cPadrao == "545";	///	Transferncia para Cobrana Advogado	FIN	FINA110
	.or. cPadrao == "546";	///	Transferncia para Cobrana Judicial	FIN	FINA110

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "547";	///	Border para Carteira						FIN	FINA110
	.or. cPadrao == "548";	///	Border para Cobrana Simples				FIN	FINA110
	.or. cPadrao == "549";	///	Border para Cobrana Descontada			FIN	FINA110
	.or. cPadrao == "550";	///	Border para Cobrana Caucionada			FIN	FINA110
	.or. cPadrao == "551";	///	Border para Cobrana Vinculada				FIN	FINA110
	.or. cPadrao == "552";	///	Border para Cobrana Advogado				FIN	FINA110
	.or. cPadrao == "553";	///	Border para Cobrana Judicial				FIN	FINA110
	.or. cPadrao == "554";	///	Cancelamento de Border						FIN	FINA110
	.or. cPadrao == "555";	///	Transferncia para Cob.Caucionada DescontadaFIN	FINA110
	.or. cPadrao == "556"	///	Border para Cobrana Caucionada Descontada	FIN	FINA110

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SEA"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "566";	///	Gerao de Cheques sobre Ttulos	FIN	FINA390/FINA370
	.or. cPadrao == "567";	///	Gerao de Cheques Avulsos		FIN	FINA390/FINA370
	.or. cPadrao == "568";	///	Cancelamento de Cheque Avulso	FIN	FINA390
	.or. cPadrao == "571"	///	Cancelamento de Cheques sobre Ttulos	FIN	FINA390

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SEF"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "569"	///	Redepsito de Cheque sobre Ttulos		FIN	FINA390

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "572";	///	Movimentos do Caixinha										FIN	FINA550
	.or. cPadrao == "573"	///	Movimentos de Reposio - Banco/Caixinha - Caixinha/Banco	FIN	FINA550/FINA370

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SEU"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE	 cPadrao == "580";	///	Aplicao Financeira			FIN	FINA171/FINA370
	.or. cPadrao == "581";	///	Excluso Aplicao Financeira	FIN	FINA171/FINA370
	.or. cPadrao == "582";	///	Apropriao / Resgate de Emprstimo	FIN	FINA171/FINA370
	.or. cPadrao == "584";	///	Estorno Apropriao Aplicao Financeira	FIN	FINA171/FINA370
	.or. cPadrao == "585";	///	Resgate Aplicao Financeira	FIN	FINA171/FINA370
	.or. cPadrao == "586"	///	Estorno Emprstimo / Estorno do Resgate de Aplicao Financeira	FIN	FINA171/FINA370

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "588";	///	Cancelamento Compensao de Contas a Receber	FIN	FINA330
	.or. cPadrao == "596"	///	Compensao Contas a Receber					FIN	FINA330/FINA370

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS
	EndIf

CASE 	 cPadrao == "589";	///	Cancelamento Compensao de Contas a Pagar		FIN	FINA340
	.or. cPadrao == "597"	///	Compensao Contas a Pagar						FIN	FINA340/FINA370

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf
	lTotalizador := VALOR > 0

CASE 	 cPadrao == "590";	///	Gerao de Cheques		FIN	FINA190/FINA370
	.or. cPadrao == "591"	///	Cancelamento de Cheques	FIN	FINA190

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "592";	///	Cancelamento Faturas a Receber	FIN	FINA280
	.or. cPadrao == "595"	///	Faturas a Receber				FIN	FINA280

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "594"	///	Compensao entre Carteiras	FIN	FINA450

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "598"	///	Variao Monetria - Contas a Receber	FIN	FINA350

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "599"	///	Variao Monetria - Contas a Pagar	FIN	FINA350

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "605";	///	Apurao de PIS. Este lanamento somente  executado quando h gerao de contas a pagar. (A tabela de ttulos a pagar est posicionada).	FIS	MATA996
	.or. cPadrao == "606";	///	Apurao de COFINS. Este lanamento somente  executado quando h gerao de contas a pagar. (A tabela de ttulos a pagar est posicionada).	FIS	MATA996
	.or. cPadrao == "611";	///	Estorno da Apurao de PIS. Este lanamento somente  executado quando h gerao de contas a pagar. (A tabela de titulos a pagar est posicionada).	FIS	MATA996/MATA997
	.or. cPadrao == "608";	///	Estorno da Apurao de CONFIS. Este lanamento somente  executado quando h gerao de contas a pagar. (A tabela de titulos a pagar est posicionada).	FIS	MATA996
	.or. cPadrao == "765";	///	Inclusao CPRB. Este lanamento somente  executado quando h gerao de contas a pagar. (A tabela de titulos a pagar est posicionada).	FIS	MATA996
	.or. cPadrao == "766"	///	Estorno CPRB. Este lanamento somente  executado quando h gerao de contas a pagar. (A tabela de titulos a pagar est posicionada).	FIS	MATA996


	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "610"		///	Contabilizao dos itens do documento de sada - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, documento de sada e Cliente ou Fornecedor conforme o tipo do documento.	FAT	CTBANFS

	If GetNewPar("MV_OPTNFS",.F.) .and. ALLTRIM(UPPER(FunName())) == "CTBANFS"
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "CTBANFS"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		If cTabOrigem == "CTBANFS"
			nRecOrigem := CTBANFS->(SD2RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	Else
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "SD2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		nRecOrigem := (cTabOrigem)->(Recno())
	EndIf

	cTabOrigem := "SD2"		/// INDEPENDENTE DE QUERY RETORNA A TABELA PADRAO PARA O RASTREAMENTO

CASE 	 cPadrao == "620"		///	Contabilizao do documento de sada - Disponvel a tabelas de Cliente ou Fornecedor conforme o tipo do documento.	FAT	CTBANFS

	If GetNewPar("MV_OPTNFS",.F.) .and. ALLTRIM(UPPER(FunName())) == "CTBANFS"
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "CTBANFS"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		If cTabOrigem == "CTBANFS"
			nRecOrigem := CTBANFS->(SF2RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	Else
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "SF2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		nRecOrigem := (cTabOrigem)->(Recno())
	EndIf

	cTabOrigem := "SF2"		/// INDEPENDENTE DE QUERY RETORNA A TABELA PADRAO PARA O RASTREAMENTO

CASE 	 cPadrao == "612";	///	Contabilizao dos itens do pedido de venda
	.or. cPadrao == "621"	///	Contabilizao do cabealho do pedido de venda

	If GetNewPar("MV_OPTNFS",.F.) .and. ALLTRIM(UPPER(FunName())) == "CTBANFS"
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "CTBANFS"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		If cTabOrigem == "CTBANFS"
			nRecOrigem := CTBANFS->(SC5RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	Else
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "SC5"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		nRecOrigem := (cTabOrigem)->(Recno())
	EndIf

	cTabOrigem := "SC5"		/// INDEPENDENTE DE QUERY RETORNA A TABELA PADRAO PARA O RASTREAMENTO

CASE	 cPadrao == "630"		///	Contabilizao da excluso dos itens do documento de sada - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, documento de sada e Cliente ou Fornecedor conforme o tipo do documento.	FAT	CTBANFS

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SD2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE	 cPadrao == "635"		///	Contabilizao da excluso do documento de sada - Disponvel a tabelas de Cliente ou Fornecedor conforme o tipo do documento.	FAT

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SF2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "641";	///	Contabilizao do rateio dos itens do documento de entrada para Clientes - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, rateio de itens, item do documento de entrada e Cliente conforme o tipo do documento. Este lanamento no impede a execuo do lanamento 650.	COM
	.or. cPadrao == "650";	///	Contabilizao dos itens do documento de entrada - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, documento de entrada e Cliente ou Fornecedor conforme o tipo do documento.	COM
	.or. cPadrao == "640";	///	Contabilizao dos itens do documento de entrada. Esto disponveis as tabelas de Tipo de entrada e sada, cliente, produto e documento de entrada. Este lanamento somente deve ser utilizado para empresas que apropriam o custo de forma on-line.	COM
	.or. cPadrao == "651";	///	Contabilizao do rateio dos itens do documento de entrada para Fornecedor - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, rateio de itens, item do documento de entrada e Fornecedor conforme o tipo do documento. Este lanamento no impede a execuo do lanamento 650.	COM
	.or. cPadrao ==	"950"	///	Contabilizao dos itens do documento de entrada especifico para documentos de provenientes do Ambiente de Importao - Esto disponveis as tabelas de Tipo de Entrada e sada e Cliente ou Fornecedor conforme o tipo do documento. Este lanamento  executado junto com o lanamento 650.	COM

	If GetNewPar("MV_OPTNFE",.F.) .and. ALLTRIM(UPPER(FunName())) == "CTBANFE"
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "CTBANFE"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		If cTabOrigem == "CTBANFE"
			nRecOrigem := CTBANFE->(SD1RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	Else
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "SD1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		nRecOrigem := (cTabOrigem)->(Recno())
	EndIf

	cTabOrigem := "SD1"		/// INDEPENDENTE DE QUERY RETORNA A TABELA PADRAO PARA O RASTREAMENTO

CASE 	 cPadrao == "642";	///	Contabilizao da Devoluo de Vendas do Documento de Entrada pelo Total. Esto disponveis as tabelas de cliente e documento de entrada.	COM
	.or. cPadrao == "660";	///	Contabilizao do documento de entrada - Disponvel a tabelas de Cliente ou Fornecedor conforme o tipo do documento.	COM
	.or. cPadrao == "661"	///	Reservado para Localizaes	COM

	If GetNewPar("MV_OPTNFE",.F.) .and. ALLTRIM(UPPER(FunName())) == "CTBANFE"
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "CTBANFE"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		If cTabOrigem == "CTBANFE"
			nRecOrigem := CTBANFE->(SF1RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	Else
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "SF1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		nRecOrigem := (cTabOrigem)->(Recno())
	EndIf

	cTabOrigem := "SF1"		/// INDEPENDENTE DE QUERY RETORNA A TABELA PADRAO PARA O RASTREAMENTO

CASE     cPadrao == "655";	///	Contabilizao do excluso dos itens do documento de entrada - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, documento de entrada e Cliente ou Fornecedor conforme o tipo do documento.	COM
	.or. cPadrao == "656";	///	Contabilizao da excluso do rateio dos itens do documento de entrada - Esto disponveis as tabelas de Tipo de Entrada e sada, produto, documento de entrada, rateio de itens, item do documento de entrada e Cliente ou Fornecedor conforme o tipo do documento. Este lanamento no impede a execuo do lanamento 651.	COM
	.or. cPadrao == "955"	///	Contabilizao da excluso dos itens do documento de entrada especifico para documentos de provenientes do Ambiente de Importao - Esto disponveis as tabelas de Tipo de Entrada e sada e Cliente ou Fornecedor conforme o tipo do documento. Este lanamento  executado junto com o lanamento 655.	COM

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SD1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE     cPadrao == "665"	///	Contabilizao da excluso do documento de entrada - Disponvel a tabelas de Cliente ou Fornecedor conforme o tipo do documento.	COM

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SF1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "652";	///	Contabiliza a implantao dos itens do Pedido de Compras.	COM
	.or. cPadrao == "657"	///	Contabiliza a excluso dos itens do Pedido de Compras.	COM

	If GetNewPar("MV_OPTNFE",.F.) .and. ALLTRIM(UPPER(FunName())) == "CTBANFE"
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			cTabOrigem := "CTBANFE"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf

		If cTabOrigem == "CTBANFE"
			nRecOrigem := CTBANFE->(SC7RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	Else
		If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
			If ALLTRIM(UPPER(FunName())) == "CTBANFE"
				cTabOrigem := "SC7_QRY"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
			Else
				cTabOrigem := "SC7"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
			EndIf
		EndIf

		If cTabOrigem == "SC7_QRY"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
			nRecOrigem := (cTabOrigem)->(SC7RECNO)
		Else
			nRecOrigem := (cTabOrigem)->(Recno())
		EndIf
	EndIf

	cTabOrigem := "SC7"		/// INDEPENDENTE DE QUERY RETORNA A TABELA PADRAO PARA O RASTREAMENTO

CASE 	 cPadrao == "666";	///	Sada de saldo em estoque (requisio) para materiais com apropriao direta.	EST
	.or. cPadrao == "667";	///	Antes de atualizar o custo - Sada de saldo em estoque (requisio) para materiais com apropriao direta).	EST
	.or. cPadrao == "668";	///	Entrada de saldo em estoque (devoluo / produo) para materiais com apropriao direta).	EST
	.or. cPadrao == "669";	///	Antes de atualizar o custo - Entrada de saldo em estoque (devoluo/produo) para materiais com apropriao direta).	EST
	.or. cPadrao == "670";	///	Sada de saldo em estoque (requisio) - movimento origem	EST
	.or. cPadrao == "672";	///	Entrada de saldo em estoque (devoluo) - movimento destino	EST
	.or. cPadrao == "674";	///	Sada de saldo em estoque (requisio) no inventrio On-Line.	EST
	.or. cPadrao == "676";	///	Entrada de saldo em estoque (Devoluo/Produo) no inventrio On-Line.	EST
	.or. cPadrao == "679";	///	Entrada de saldo em estoque (devoluo / produo) para materiais com apropriao indireta).	EST
	.or. cPadrao == "680"	///	Sada de saldo em estoque (requisio) para materiais com apropriao indireta.	EST

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SD3"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE     cPadrao == "678"	///	Venda de mercadoria (item do Documento de Sada)	EST

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SD2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE	 cPadrao == "681";	///	Compra / Remessa de terceiros (item Documento Entrada)	EST
	.or. cPadrao == "682"	///	Retorno poder de terceiros (item Documento Entrada)	EST

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SD1"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "710";	///	Apurao de ICMS. Este lanamento somente  executado quando h gerao de contas a pagar (parmetro MV_LPADICM - A tabela de ttulos a pagar esta posicionada).	FIS
	.or. cPadrao == "711";	///	Estorno da Apurao de ICMS. Este lanamento somente  executado quando h gerao de contas a pagar (parmetro MV_LPADICM - A tabela de ttulos a pagar esta posicionada).	FIS
	.or. cPadrao == "720";	///	Apurao de IPI. Este lanamento somente  executado quando h gerao de contas a pagar (parmetro MV_LPADIPI - A tabela de ttulos a pagar esta posicionada).	FIS
	.or. cPadrao == "721"	///	Estorno da Apurao de IPI. Este lanamento somente  executado quando h gerao de contas a pagar (parmetro MV_LPADIPI - A tabela de ttulos a pagar esta posicionada	FIS

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SE2"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE cPadrao == "730"	///	Reservado para Localizaes	FIS

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "SCN"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "750";	///	Apurao de ISS			FIS
	.or. cPadrao == "751"	///	Estorno Apurao ISS	FIS

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		// cTabOrigem := "SCM"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

CASE 	 cPadrao == "801";	///	Aquisio de Bem	ATF
	.or. cPadrao == "802";	///	Aquisio - Reavaliao	ATF
	.or. cPadrao == "803";	///	Aquisio - Adiantamento	ATF
	.or. cPadrao == "804";	///	Aquisio - Lei 8.200	ATF
	.or. cPadrao == "805";	///	Excluso Aquisio do Bem	ATF
	.or. cPadrao == "806";	///	Excluso - Reavaliao	ATF
	.or. cPadrao == "807";	///	Excluso - Adiantamento	ATF
	.or. cPadrao == "808";	///	Excluso - Lei 8.200	ATF
	.or. cPadrao == "845";	///	Aquisio - Lei 8.200 (Tipo do Ativo - 06)	ATF
	.or. cPadrao == "846"	///	Excluso - Lei 8.200 (Tipo do Ativo - 06 )

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		If cPadrao == "801"
			cTabOrigem := "SN4"
		Else
			cTabOrigem := "SN3"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		Endif
	EndIf

CASE  	 cPadrao == "810";	///	Baixa Aquisio	ATF
	.or. cPadrao == "811";	///	Baixa Reavaliao	ATF
	.or. cPadrao == "812";	///	Baixa - Adiantamentos	ATF
	.or. cPadrao == "812";	///	Baixa Adiantamento	ATF
	.or. cPadrao == "813";	///	Baixa Lei 8.200	ATF
	.or. cPadrao == "814";	///	Cancelamento Baixa Aquisio	ATF
	.or. cPadrao == "815";	///	Cancelamento Baixa Reavaliao	ATF
	.or. cPadrao == "816";	///	Cancelamento Baixa Adiantamento	ATF
	.or. cPadrao == "817";	///	Cancelamento Baixa Lei 8.200	ATF
	.or. cPadrao == "847";	///	Baixa Lei 8.200 (Tipo do Ativo - 06)	ATF
	.or. cPadrao == "848";	///	Cancelamento da Baixa (Tipo do Ativo - 06)	ATF
	.or. cPadrao == "820";	///	Clculo da Depreciao	ATF
	.or. cPadrao == "821";	///	Ampliao	ATF
	.or. cPadrao == "822";	///	Cancelamento de Ampliao	ATF
	.or. cPadrao == "825";	///	Desclculo	ATF
	.or. cPadrao == "827";	///	Ajuste Inventrio	ATF
	.or. cPadrao == "831";	///	Transferencia  ATF (origem)
	.or. cPadrao == "832"	///	Transferencia  ATF (destino)

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		If cPadrao == "810" .OR. cPadrao == "820"
			cTabOrigem := "SN4"
		Else
			cTabOrigem := "SN3"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
		EndIf
	EndIf

CASE 	 cPadrao == "8A2";	///	Putting Into Operation
	.or. cPadrao == "8A3"	///	Storno of Putting Into Operation

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "F4R"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

	nRecOrigem := F4R->(Recno())

CASE 	 cPadrao == "8A6";	///	Conservation
	.or. cPadrao == "8A7";	///	Storno of Conservation
	.or. cPadrao == "8A8";	///	Storno of Conservation
	.or. cPadrao == "8A9"	///	Storno of Conservation

	If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
		cTabOrigem := "F44"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
	EndIf

	nRecOrigem := F44->(Recno())

CASE	cPaisLoc == "RUS" .And. cPadrao == "5BS"
	If Empty(cTabOrigem)
		cTabOrigem := "SEL"
	EndIf

	nRecOrigem := SEL->(Recno())

CASE 	 cPadrao >= "A01" .and. cPadrao <= "C06"
/*
"A01"	///	Salrios a Pagar		GPE		SRZ
"A02"	///	Frias					GPE		SRZ
"A03"	///	Salrio Famlia			GPE		SRZ
"A04"	///	Salrio Maternidade		GPE		SRZ
"A05"	///	Pr-Labore				GPE		SRZ
"B01"	///	INSS Empregados			GPE		SRZ
"B02"	///	IRRF					GPE		SRZ
"B03"	///	Assistncia Mdica		GPE		SRZ
"B04"	///	Contribuio Sindical	GPE		SRZ
"B05"	///	Faltas					GPE		SRZ
"B06"	///	Aviso Prvio (Desconto)	GPE		SRZ
"B07"	///	Outros Descontos		GPE		SRZ
"B08"	///	Penso Alimentcia		GPE		SRZ
"B09"	///	Vale-Transporte			GPE		SRZ
"B10"	///	Desc. Insufic. de Saldo	GPE		SRZ
"C01"	///	INSS Empresa			GPE		SRZ
"C02"	///	FGTS					GPE		SRZ
"C03"	///	Proviso de Frias		GPE		SRZ
"C04"	///	Encargos Prov.de Frias	GPE		SRZ
"C05"	///	Proviso de 13 Salrio	GPE		SRZ
"C06"	///	Encargos de Prov.13Sal.GPE		SRZ
*/
If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
	cTabOrigem := "SRZ"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
EndIf
Case cPadrao == '69K'
If Empty(cTabOrigem)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
	cTabOrigem := "CN9"	/// ASSUME A TABELA PADRAO ASSOCIADA AOS LANAMENTOS.
EndIf
ENDCASE

If Empty(cTabOrigem) .and. !Empty(cAliasPos)	/// SE A TABELA DE ORIGEM FOR INDICADA EM BRANCO
	cTabOrigem := cAliasPos 					/// ASSUME A TABELA ABERTA AO CHAMAR A DETPROVA
EndIf

If !lTotalizador .and. nRecOrigem <= 0 .and. !Empty(cTabOrigem)
	nRecOrigem := (cTabOrigem)->(Recno())
Endif

If nPosORISE2 > 0
	SE2->(MsGoTo(nPosORISE2))
EndIf

If nPosORISE5 > 0
	SE5->(MsGoTo(nPosORISE5))
EndIf

Return(nRecOrigem)

/*


ͻ
Programa  dbNickOrdeAutor  Marcos S. Lobo       Data   01/26/06   
͹
Desc.     Localiza indice pelo NickName e seta ordem se existir.	  
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function dbNickOrder(cAlias,cNick)

Local aAreaPos := GetArea()
Local nRet	   := 0

If Empty(cAlias) .or. ValType(cAlias) <> "C"
	Return 0
EndIf
If Empty(cNick) .or. ValType(cNick) <> "C"
	Return 0
EndIf

cNick := ALLTRIM(UPPER(cNick))

dbSelectArea("SIX")
dbSetOrder(1)
If dbSeek(cAlias,.F.)
	While SIX->(!Eof()) .and. SIX->INDICE == cAlias
		If ALLTRIM(UPPER(SIX->NICKNAME)) == cNick
			dbSelectArea(cAlias)		/// SELECIONA O ALIAS INDICADO
			DBOrderNickName(cNick)		/// SETA O INDICE PELO NICK
			nRet := IndexOrd()			/// RETORNA O NUMERO DO INDICE
			Exit
		EndIf
		SIX->(dbSkip())
	EndDo
Else
	/// RESTAURA AREA APENAS SE NO ENCONTROU O NDICE
	RestArea(aAreaPos)
EndIf

Return nRet


/*


ͻ
Programa  CtbCfgLancAutor  Edson Maricate       Data   24/02/06   
͹
Descricao Cria uma tela de configurao on line de lanamentos        
͹
Uso        Contabilidade Gerencial - Lanamentos Automaticos          
           Atencao! Esta fucao e chamada pela DetProva e utilizada    
           em todo o sistema!                                         
ͼ


*/
Function CtbCfgLanc(cPadrao,lPosiciona)

Local aArea
Local aAreaCT5
Local oDlg
Local oTree
Local oTree2
Local aHeadCT5		:= {}
Local aColsCT5		:= {}
Local aRecCT5		:= {}
Local nLenCT5 		:= 0
Local nLinCT5 		:= 0
Local aSize //:= MsAdvSize(,.F.,400)
Local aHeadCTK		:= {}
Local aColsCTK		:= {}
Local nLenCTK 		:= 0
Local nLinCTK		:= 0
Local lOk			:= .F.
Local nPosAtivo
Local cX			:= ""
Local cVar		:= SPACE(100)
Local oBold
Local oPanel, oFolder, oPanel3, oPanel4, oPanel5, oPanel6, oPanel21, oPanel22
Local nColAux

If AliasInDic("CVA")
	dbSelectArea("CVA")
	dbSetOrder(1)
	//Ŀ
	//Possibilita a utilizao da tela para qualquer login CVA_CFGLAN = "1"    
	//ou apenas para o usurio Administrador CVA_CFGLAN = "3"                  
	//
	If MsSeek(xFilial()+cPadrao) .And. ( CVA->CVA_CFGLAN == "1" .Or. (__cUserID == "000000" .And. CVA->CVA_CFGLAN == "3") )
		aSize := MsAdvSize(,.F.,400) //RETIRADO DA DECLARACAO VARIAVEL LOCAL ASIZE POR MOTIVO DE PERFORMANCE
		PRIVATE M->CT5_LANPAD	:= cPadrao
		PRIVATE cTable				:= "   "
		Private oGdCTK
		Private oGdCT5


		aArea			:= GetArea()
		aAreaCT5		:= CT5->(GetArea())

		//Ŀ
		// Montagem do aHeader do CT5                                             
		//
		aHeadCT5 := GetaHeader("CT5",,{"CT5_LANPAD"},{})
		nLenCT5  := Len(aHeadCT5) + 1
		nPosAtivo:= AScan(aHeadCT5,{|x| Upper(AllTrim(x[2])) == "CT5_STATUS" })

		//Ŀ
		// Montagem do aCols do CT5                                               
		//
		aColsCT5 := {}
		DbSelectArea("CT5")
		DbSetOrder(1)
		DbSeek(xFilial()+cPadrao)
		While  !Eof() .And. xFilial('CT5')+cPadrao==CT5->CT5_FILIAL+CT5->CT5_LANPAD
			AAdd(aColsCT5,Array( nLenCT5 ))
			nLinCT5++
			// Varre o aHeader para preencher o acols
			AEval(aHeadCT5, {|x,y| aColsCT5[nLinCT5][y] := IIf(x[10] == "V", CriaVar(AllTrim(x[2])), FieldGet(FieldPos(x[2])) ) })

			// Deleted
			aColsCT5[nLinCT5][nLenCT5] := .F.

			// Adiciona o Recno no aRec
			AAdd( aRecCT5, CT5->( Recno() ) )

			CT5->(DbSkip())
		EndDo

		// Verifica se no foi criada nenhuma linha para o aCols
		If Len(aColsCT5) = 0
			AAdd(aColsCT5,Array( nLenCT5 ))
			nLinCT5++

			// Varre o aHeader para preencher o acols
			AEval(aHeadCT5, {|x,y| aColsCT5[nLinCT5][y] := IIf(Upper(AllTrim(x[2])) == "CT5_SEQUEN", StrZero(1,Len(CT5->CT5_SEQUEN)),CriaVar(AllTrim(x[2])) ) })

			// Deleted
			aColsCT5[nLinCT5][nLenCT5] := .F.
		EndIf


		//Ŀ
		// Montagem do aHeader do CTK                                             
		//
		dbSelectArea("CTK")

		aHeadCTK := GetaHeader("CTK",,{"CTK_SEQUEN"},{})
		nLenCTK  := Len(aHeadCTK) + 1


		//Ŀ
		// Montagem do aCols do CTK                                               
		//

		aColsCTK := {}
		AAdd(aColsCTK,Array( nLenCTK ))
		nLinCTK++
		// Varre o aHeader para preencher o acols
		AEval(aHeadCTK, {|x,y| aColsCTK[nLinCTK][y] := IIf(x[10] == "V", CriaVar(AllTrim(x[2])), FieldGet(FieldPos(x[2])) ) })

		// Deleted
		aColsCTK[nLinCTK][nLenCTK] := .F.

		// Verifica se no foi criada nenhuma linha para o aCols
		If Len(aColsCTK) = 0
			AAdd(aColsCTK,Array( nLenCTK ))
			nLinCTK++
			// Varre o aHeader para preencher o acols
			AEval(aHeadCTK, {|x,y| aColsCTK[nLinCTK][y] := IIf(Upper(AllTrim(x[2])) == "CTK_SEQUEN", StrZero(1,Len(CTK->CTK_SEQUEN)),CriaVar(AllTrim(x[2])) ) })

			// Deleted
			aColsCTK[nLinCTK][nLenCTK] := .F.
		EndIf

		dbSelectArea("CVA")
		dbSetOrder(1)
		dbSeek(xFilial()+cPadrao)

		DbSelectArea("CT5")

		DEFINE FONT oBold NAME "Arial" SIZE 0, -11 BOLD
		DEFINE MSDIALOG oDlg TITLE STR0013+cPadrao FROM aSize[7],0 to aSize[6],aSize[5] PIXEL  //"Configurao On-Line de Lancamentos - "

			oPanel := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,150,150,.T.,.T. )
			oPanel:Align := CONTROL_ALIGN_LEFT

			oFolder := TFolder():New(121,2,{STR0014,STR0015},{},oPanel,,,, .T., .T.,390,110)  //"Campos"#"Variaveis"
			oFolder:Align := CONTROL_ALIGN_ALLCLIENT

			oPanel3 := TPanel():New(0,0,'',oFolder:aDialogs[1], , .T., .T.,, ,30,30,.T.,.T. )
			oPanel3:Align := CONTROL_ALIGN_TOP

			oPanel4 := TPanel():New(0,0,'',oFolder:aDialogs[1], , .T., .T.,, ,50,50,.T.,.T. )
			oPanel4:Align := CONTROL_ALIGN_ALLCLIENT

			@ 1110,1110 MSGET oX VAR cX SIZE 1,1

			TSay():New( 3, 3, MontaBlock("{|| '"+STR0016+"' }"), oPanel3 , ,oBold,,,,.T.)//'Tabela'

			@ 10,3 MSGET oTable VAR cTable SIZE 30,10 PIXEL Of oPanel3 F3 "SX21" PICTURE '@!' VALID ExistCpo("SX2") .And. Processa({|| CfgLoadTree(cTable,oTree,.T.)}) HASBUTTON

			@ 10,40 BUTTON oIns Prompt ">>" SIZE 10 ,7  FONT oDlg:oFont ACTION {|| AddliqLan(oTree,aHeadCT5)} OF oPanel3 PIXEL When Substr(oTree:GetCargo(),1,3)=="FLD"
			TSay():New( 10, 52, MontaBlock("{|| '"+STR0017+"' }"), oPanel3 , ,oBold,,,,.T.,,,50,20)  //"Clique aqui para inserir o campo"

			oTree := DbTree():New(1,1,10,10, oPanel4,,,.T.)
			oTree:Align := CONTROL_ALIGN_ALLCLIENT


			oPanel5 := TPanel():New(0,0,'',oFolder:aDialogs[2], , .T., .T.,, ,30,30,.T.,.T. )
			oPanel5:Align := CONTROL_ALIGN_TOP

			oPanel6 := TPanel():New(0,0,'',oFolder:aDialogs[2], , .T., .T.,, ,30,30,.T.,.T. )
			oPanel6:Align := CONTROL_ALIGN_ALLCLIENT


			TSay():New( 3, 3, MontaBlock("{|| '"+STR0018+"' }"), oPanel5 , ,oBold,,,,.T.)  // "Variavel"
			@ 10,3 MSGET oVar VAR cVar SIZE 60,10 PIXEL Of oPanel5 VALID CfgLoadVar(cVar,oTree2)

			oTree2 := DbTree():New(1,1,10,10, oPanel6,,,.T.)
			oTree2:Align := CONTROL_ALIGN_ALLCLIENT

			oTree2:AddItem( Padr(STR0015,100),Padr("0",80),,,,,0)


			oPanel2 := TPanel():New(0,0,'',oDlg, oDlg:oFont, .T., .T.,, ,90,90,.T.,.T. )
			oPanel2:Align := CONTROL_ALIGN_ALLCLIENT

			oPanel21 := TPanel():New(0,0,'',oPanel2, oDlg:oFont, .T., .T.,, ,15,15,.T.,.T. )
			oPanel21:Align := CONTROL_ALIGN_TOP

			TSay():New( 3, 4, MontaBlock("{|| '"+STR0019+" - "+cPadrao+" - "+AllTrim(CVA->CVA_DESCRI)+"' }"), oPanel21 , ,oBold,,,,.T.)  //"Configurao dos Lancamentos Padres"

			oGdCT5:= MsNewGetDados():New(0,0,70,70,GD_INSERT+GD_UPDATE+GD_DELETE,,,,,,9999,,,,oPanel2,aHeadCT5,aColsCT5)
			oGdCT5:oBrowse:Align := CONTROL_ALIGN_TOP
			oGdCT5:CARGO := AClone(aRecCT5)

			For nColAux := 1 TO Len(oGdCT5:aHeader)
				//verifica se valid esta preenchido e coloca funcao para inicializar variaveis M->
				If ! Empty(oGdCT5:aHeader[nColAux, 6])
					oGdCT5:aHeader[nColAux, 6] := "CtbVarMem(oGdCT5) .And. "+Alltrim(oGdCT5:aHeader[nColAux, 6])
				EndIf
			Next //nColAux

			oPanel22 := TPanel():New(0,0,'',oPanel2, oDlg:oFont, .T., .T.,, ,15,15,.T.,.T. )
			oPanel22:Align := CONTROL_ALIGN_TOP

			TSay():New( 3, 4, MontaBlock("{|| '"+STR0020+"' }"), oPanel22 , ,oBold,,,,.T.)  //"Pr-Visualizao dos Lancamentos"
			@1,250 BTNBMP oBmp1 RESOURCE "RELOAD"   SIZE 25,25 ACTION CtbAtuGrid(@oGDCT5,@oGDCTK, 1,lPosiciona,cPadrao) Of oPanel22

			oGdCTK:= MsNewGetDados():New(0,0,100,100,0,,,,,,9999,,,,oPanel2,aHeadCTK,aColsCTK)
			oGdCTK:oBrowse:Align := CONTROL_ALIGN_ALLCLIENT

			CtbAtuGrid(oGDCT5,oGDCTK, 1,lPosiciona,cPadrao)

		If SetMDIChild()
			ACTIVATE MSDIALOG oDlg ON INIT EnchoiceBar(oDlg,{|| If(Aviso(STR0002,STR0021,{STR0022,STR0023},2)==1.And.CtbLctoOk(oGdCT5,cPadrao),oDlg:End(),Nil) },{|| oDlg:End() })  //"Ateno!"#"Confirma gravaao da configurao dos lanamentos padres de acordo com as modificaes efetuadas ?"#"Sim"#"No"
		Else
			ACTIVATE MSDIALOG oDlg CENTERED ON INIT EnchoiceBar(oDlg,{|| If(Aviso(STR0002,STR0021,{STR0022,STR0023},2)==1.And.CtbLctoOk(oGdCT5,cPadrao),oDlg:End(),Nil) },{|| oDlg:End() }) //"Ateno!"#"Confirma gravaao da configurao dos lanamentos padres de acordo com as modificaes efetuadas ?"#"Sim"#"No"
		EndIf

		RestArea(aAreaCT5)
		RestArea(aArea)
	EndIf
EndIf

Return

/*


ͻ
Programa  CtbVarMem Autor  Microsiga            Data   12/01/10   
͹
Desc.     Coloca as colunas do acols em variaveis memoria M->campo    
          (exceto a coluna posicionada)                               
͹
Uso        AP                                                         
ͼ


*/
Function CtbVarMem(oGdCT5)
Local nLin := oGdCT5:nAt
Local nX
For nX := 1 TO Len(oGdCT5:aCols[nLin])-1
	If nX != oGdCT5:oBrowse:ColPos
		_SetOwnerPrvt(Trim(oGdCT5:aHeader[nX,2]), oGdCT5:aCols[nLin, nX])  //		&("M->"+oGdCT5:aHeader[nX,2]) := oGdCT5:aCols[nLin, nX]
	EndIf
Next
Return(.T.) //tem que retornar .T.


/*


ͻ
Funo     CtbAtuGridAutor   Microsiga		  Data   00/00/00   
͹
Desc.      Funo que atualiza o grid com os valores do lanamento	  
           padro logo aps o processo do sistema seja finalizado e   
           necessite efetuar uma contabilizao online				  
͹
Uso        Lanamento Padro										  
ͼ


*/
Static Function CtbAtuGrid(oGDCT5,oGDCTK, nOpcCfg,lPosiciona,cPadrao)

Local nz
Local nx
Local bBlock		:= ErrorBlock()
Local aColsOri 	:= aClone(oGDCTK:aCols)
Local aVlrCT5 		:= Array(__nQuantas)
Local cValor     := ""
Local cHistorico := ""
Local cHist      := ""
Local cHAglut	 := ""
Local nPosCtk
Local lRedStorn	:= cPaisLoc == "RUS" .And. SuperGetMV("MV_REDSTOR",.F.,.F.)

ErrorBlock( {|e| ChecErro(e)})

If __nQuantas == 0
	__nQuantas := CtbMoedas()
EndIf

Begin Sequence

	oGDCTK:aCols := {}

	For nx := 1 to Len(oGDCT5:aCols)

		If oGDCT5:aCols[nx][Len(oGDCT5:aCols[nx])] // Deletado
			Loop
		EndIf

		If oGDCT5:aCols[nx][aScan(oGDCT5:aHeader,{|x| Alltrim(x[2]) == "CT5_DC" })] == "4" // Continuao historico
			Loop
		EndIf

		//Ŀ
		// Indica que o lancamento padrao esta inativo                  
		//
		nPosStatus := aScan(oGDCT5:aHeader,{|x| Alltrim(x[2]) == "CT5_STATUS" })
		If nPosStatus > 0
			If oGDCT5:aCols[nx][nPosStatus] == "2"
				Loop
			EndIf
		EndIf

		aVlrCT5   := AFill(aVlrCT5,0)
		nContador := 0


		//Ŀ
		// Verifica se existem valores a serem contabilizados.          
		//                                                              
		// Como os valores podem ser expressoes complexas estes sao     
		// armazenados na variavel aVlrCt5 para que nao haja necessidade
		// de serem executados novamente.                               
		//
		For nZ := 1 To __nQuantas
			nValor    := 0
			cCampoCT5 := "CT5_VLR"+StrZero(nZ,2)
			nPosCT5 := aScan(oGDCT5:aHeader,{|x| Alltrim(x[2]) == cCampoCT5 })
			If nPosCT5 > 0
				cValor := AllTrim(oGDCT5:aCols[nx][nPosCT5])
				nValor := &(cValor)
				If Empty(nValor) .Or. nValor == 0
					nContador++
				Else
					aVlrCT5[nZ] := nValor
				EndIf
			EndIf
		Next nZ
		//Ŀ
		// Se houver valores para contabilizar                          
		//
		If nContador <> __nQuantas

			AAdd(oGDCTK:aCols,Array( Len(oGDCTK:aHeader)+1 ))
			nLinCTK := Len(oGDCTK:aCols)
			// Varre o aHeader para preencher o acols
			AEval(oGDCTK:aHeader, {|x,y| oGDCTK:aCols[nLinCTK][y] := CriaVar(AllTrim(x[2])) } )

			// Deleted
			oGDCTK:aCols[nLinCTK][Len(oGDCTK:aHeader)+1] := .F.


			For nPosCtk := 1 To Len(oGDCTK:aHeader)
				//Ŀ
				// Obtem o nome do campo de destino na tabela CTK               
				//
				cCampoCTK := AllTrim(oGDCTK:aHeader[nPosCtk][2])
				//Ŀ
				// Obtem o nome do campo de origem na tabela CT5                
				//
				cCampoCT5 := "CT5_" + SubStr(cCampoCTK,5)

				//Ŀ
				// Transfere os valores do campo                                
				//
				nPosCT5 := aScan(oGDCT5:aHeader,{|x| Alltrim(x[2]) == cCampoCT5 })
				If nPosCT5 > 0
					Do Case
					Case SubStr(cCampoCT5,1,7)=="CT5_VLR"
						nValor := Val(SubStr(cCampoCT5,8,2))
						If nValor <= Len(aVlrCT5)
							If aVlrCT5[nValor] > 0 .Or. (lRedStorn .And. aVlrCT5[nValor] < 0)
								oGDCTK:aCols[nLinCTK][nPosCtk] := aVlrCT5[nValor]
							EndIf
						EndIf
					Case oGDCTK:aHeader[nPosCtk][8] == "N"
						cValor	:= AllTrim(oGDCT5:aCols[nx][nPosCT5])
						If !Empty(cValor)
							nValor := &(cValor)
							oGDCTK:aCols[nLinCTK][nPosCtk] := nValor
						Else
							oGDCTK:aCols[nLinCTK][nPosCtk] := 0
						EndIf
					Case oGDCTK:aHeader[nPosCtk][8] == "C"
						If !(cCampoCT5 $ "CT5_USERGI/CT5_USERGA/CT5_TABORI/CT5_RECORI")
							If cCampoCT5 == "CT5_SBLOTE"
								cValor := AllTrim(oGDCT5:aCols[nx][nPosCT5])
							ElseIf cCampoCT5 == "CT5_FILIAL"
								cValor := xFilial("CTK")
							ElseIf cCampoCT5 == "CT5_TPSALD"
								cValor := AllTrim(oGDCT5:aCols[nx][nPosCT5])
							Else
								cValor := AllTrim(TransLcta(AllTrim(oGDCT5:aCols[nx][nPosCT5]),240))
								If cCampoCT5 == "CT5_HIST"
									cHistorico := cValor
								ElseIf cCampoCT5 == "CT5_HAGLUT"
									If Empty(cValor)			/// SE HAGLUT ESTIVER EM BRANCO ASSUME HISTORICO.
										cValor := cHistorico
									EndIf
									cHAglut := cValor
								EndIf
							EndIf
							oGDCTK:aCols[nLinCTK][nPosCtk] := cValor
						EndIf
					Case oGDCTK:aHeader[nPosCtk][8] == "D"
						cValor := Ctod(AllTrim(TranslDta(AllTrim(oGDCT5:aCols[nx][nPosCT5]) )))
						cValor := IIf(Empty(cValor),Ctod(""),cValor)
						oGDCTK:aCols[nLinCTK][nPosCtk] := cValor
					EndCase
				EndIf
			Next nPosCTK
		EndIf
	Next nx

	oGDCTK:oBrowse:Refresh()
	ErrorBlock(bBlock)

Recover

oGDCTK:aCols := aClone(aColsOri)
oGDCTK:oBrowse:Refresh()

ErrorBlock(bBlock)

End Sequence

Return .T.

/*


ͻ
Programa   AddliqLan  Autor  Edson Maricate       Data  10/10/05 
͹
Descricao  Atualiza a coluna da aCols com o campo selecioando no     
           painel lateral com a estrutura da tabela.                 
͹
Parametros oTree    : Objeto tree com a estrutura da tabela          
           aHeadTmp : aHeader com o cabecalho do aCols posicionado   
͹
Uso        SIGACTB                                                   
ͼ


*/
Static Function AddliqLan(oTree,aHeadTmp)

local oGDTmp
local cColuna := ""
local cCampo  := ""

// Cria um objeto de GetDados temporario a partir da GetDados de origem: lancamento ou bloqueio
oGDTmp  := oGDCT5

// Guarda o conteudo da coluna da aCols e o nome do campo da tabela selecionada no painel lateral
cColuna := Alltrim(oGDTmp:aCols[oGDTmp:nAt][oGdTmp:oBrowse:nColPos])
cCampo  := Alltrim(Substr(oTree:GetCargo(),4,Len(oTree:GetCargo())))

// Soma o campo selecionado no conteudo do campo no aCols posicionado
oGDTmp:aCols[oGDTmp:nAt][oGdTmp:oBrowse:nColPos] := PadR( cColuna + cTable + "->" + cCampo, TamSX3(aHeadTmp[oGdTmp:oBrowse:nColPos][2])[1] )

// Restaura o objeto da GetDados utilizado a partir das alteracoes realizadas no objeto temporario
oGDCT5 := oGDTmp

Return

/*


ͻ
Funo     CtbLctoOkAutor   Microsiga	  		  Data   00/00/00   
͹
Desc.      Funo que valida as informaes do grid com os valores do 
           lanamento padro logo aps o processo do sistema seja 	  
           finalizado enecessite efetuar uma contabilizao online	  
͹
Uso        Lanamento Padro										  
ͼ


*/

Static Function CtbLctoOk(oGd,cPadrao)

Local nI

If !LanctoVld(oGd)
	Return .F.
EndIf

// Grava as configuracoes dos Lancamento
For nI := 1 To Len(oGd:aCols)
	If nI <= Len(oGd:Cargo) .And. oGd:Cargo[nI] > 0
		CT5->(DbGoto(oGd:Cargo[nI]))
		Reclock("CT5",.F.)
	Else
		If oGd:aCols[nI][Len(oGd:aCols[nI])] // Verifica se a linha esta deletada
			Loop
		Else
			Reclock("CT5",.T.)
		EndIf
	EndIf

	If oGd:aCols[nI][Len(oGd:aCols[nI])] // Verifica se a linha esta deletada
		CT5->(DbDelete())
	Else
		// Varre o aHeader e grava com base no acols
		AEval(oGd:aHeader,{|x,y| FieldPut( FieldPos(x[2]) , oGd:aCols[nI][y] ) })
		Replace CT5_FILIAL With xFilial("CT5")
		Replace CT5_LANPAD With cPadrao
	EndIf

	MsUnlock()
Next nI

If Aviso(STR0024,STR0025+cPadrao+" ) ",{STR0022,STR0023},2) == 1 //"Desativar Modo On-Line ?"#"Deseja desativar a configurao On-Line dos lanamentos neste momento ? ( "
	dbSelectArea("CVA")
	dbSetOrder(1)
	dbSeek(xFilial()+cPadrao)
	RecLock("CVA",.F.)
	CVA->CVA_CFGLAN := "2"
	MsUnlock()
EndIf

Return .T.

/*


ͻ
Funo     LanctoVldAutor   Microsiga		  Data   00/00/00   	  
͹
Desc.      Funo que valida das colunas do grid com os valores do 	  
           lanamento padro logo aps o processo do sistema seja 	  
           finalizado enecessite efetuar uma contabilizao online	  
͹
Uso        Lanamento Padro										  
ͼ


*/
Static Function LanctoVld(oGd)
Local nI
Local nPosField

For nI := 1 To Len(oGd:aCols)
	// Busca por campos obrigatorios que nao estjam preenchidos
	nPosField := AScanx(oGd:aHeader,{|x,y| x[17] .And. Empty(oGd:aCols[nI][y]) })
	If nPosField > 0
		HELP("  ",1,"OBRIGAT2",,AllTrim(FWX2Nome("CT5"))+CHR(10)+CHR(13)+STR0026 + AllTrim(oGd:aHeader[nPosField][1]) + STR0027+Str(nI,3,0),3,1)  //"Campo:" # "Linha : "
		Return .F.
	EndIf
Next nI

Return .T.


/*

-Ŀ
Funo     ImpTerm2() Autor  Daniel Tadashi Batori  Data  29/06/06 
-Ĵ
Descrio  Imprime Termo de Abertura/Encerramento de Livro             
			  Criado apartir da ImpTerm()							            
-Ĵ
Sintaxe    ImpTerm(cArquivo,aVariavel,cImpCtrl)                        
           Parametros:                                                 
           cArquivo=Nome do Arquivo que contem script a ser impresso   
                    XXXXXXXX.XXX                                       
           aVariavel=Array com                                         
                     {{Variavel no script,Conteudo a Substituir},...}  
           cImpCtrl=Caracter de Controle de Impressao                  
           oReport=objeto do TReport               						   
-
 Uso       Generico                                                    
-ٱ


*/
Function ImpTerm2(cArquivo,aVariavel,cImpCtrl,lGraph,aGraph, oReport)

//Ŀ
// Define variaveis                                 
//

Local 	cTermo      :=""
Local   aTermo      :={""}
Local   i           :=1
Local   j           :=1
Local   nTamArq     :=0
Local   aParametros :={}
Local   nLinTermo   :=0
Local   nColTermo   :=0
Local   CR          := Chr(13)+Chr(10)
Local	cAux		:=	""
Local   cAux2		:=	""
Local	nY

If cArquivo <> Nil .And. ".DOC" $ Upper(cArquivo) .And. File(cArquivo)
	TermoViaWord(cArquivo)	// Retorno falso pois nao eh impresso pelo sistema e sim pelo WORD
	Return .F.				// utilizando .TRM apos saida da funcao eh dado EJECT que nao deve
Endif						// ser feito


If ValType(lGraph) <> "L"
	lGraph := .F.
Else
	If ValType(aGraph) <> "A"
		Return .F.
	Endif
	oPrt := aGraph[1]
Endif

//Ŀ
// Verifica se arquivo existe                       
//

If  Empty(cArquivo) .or. !File(cArquivo)
	Return .f.
Endif

//Ŀ
// Carrega arquivo                                  
//

nTerHdl :=FOPEN(cArquivo,2+64)
nTamArq :=FSEEK(nTerHdl,0,2)
xBuffer :=Space(nTamArq)
FSEEK(nTerHdl,0,0)
FREAD(nTerHdl,@xBuffer,nTamArq)
FCLOSE(nTerHdl)

//Ŀ
// Ao desmontar o arquivo para impressao, transfor- 
// ma os Chr(141) para Chr(13) atraves da HardCr()  
// e elimina os codigos Chr(10) de quebra de linha  
// para que o contole da quebra seja feito apenas   
// pelo chr(13) na montagem do Vetor de Impressao   
//

cTermo  := strtran(xBuffer , chr(10) , "")

While !empty(cTermo)
	i := at( chr(13), cTermo )
	If i > 0
		AADD(aTermo,Left(cTermo,i-1))
		cTermo := Substr(cTermo,i+1)
	Else
		aadd(aTermo,cTermo)
		cTermo:=""
	Endif
EndDo

//Ŀ
// Substitui variaveis                              
//

nTamTerm:=Len(aTermo)

nNumPar:=0
aEval(aVariavel,{ |x| IIf(!Empty(x[1]),nNumPar:=nNumPar+1,)})

For i:=1 to nTamTerm
	For j:=1 to nNumPar
		cTipo:=Valtype(aVariavel[j,2])
		Do Case
		Case cTipo=="N"
			cValor:=LTrim(Str(aVariavel[j,2]))
		Case cTipo=="D"
			cValor:=DtoC(aVariavel[j,2])
		Case cTipo=="L"
			cValor:=IIF(aVariavel[j,2],STR0022,STR0023) // "SIM"  ### "NAO"
		Case cTipo=="C"
			cValor:=aVariavel[j,2]
		EndCase
		//Ŀ
		//Tratamento para substituir exatamente o campo requerido, pois estava     
		//   ocorrendo de existir um campo _CPF e _CPFRES na mesma tabela e        
		//   quando ele iria procurar o _CPF para substituir, alterava onde estava 
		//   o _CPFRES.                                                            
		//
		If At(aVariavel[j,1], aTermo[i])>0
			cAux	:=	SubStr(aTermo[i],At(aVariavel[j,1], aTermo[i]))
			cAux2	:=	""
			For nY := 1 To Len(cAux)
				If IsAlpha(SubStr(cAux,nY,1)) .Or. SubStr(cAux,nY,1)$"_1234567890"
					cAux2 += SubStr(cAux,nY,1)
				Else
					Exit
				EndIf
			Next nY

			//Somente quando for o mesmo campo entre a tabela e o exigido no layout do termo.
			If cAux2==aVariavel[j,1]
				aTermo[i]:=StrTran(aTermo[i],aVariavel[j,1],cValor)
			EndIf
		EndIf
	Next
Next

//Ŀ
// Imprime termo                                    
//

nLinTermo:=0
nColTermo:=0

If !lGraph
//	@ nLinTermo, nColTermo PSAY cImpCtrl // Caracter de Controle de Impressao

	For i:=1 to nTamTerm
		If ValType(oReport) == "O"
			oReport:PrintText(aTermo[i])
		Else
			@ nLinTermo++, nColTermo PSAY aTermo[i]
		Endif
	Next
Else
	nLinTermo := aGraph[3]
	oPrt:Say(nLinTermo+=1,00,cImpCtrl)	// Caracter de Controle de Impressao
	For i:=1 to nTamTerm
		oPrt:Say(nLinTermo+=15,00,aTermo[i],aGraph[2])
	Next
Endif

Return .t.


/*


ͻ
Programa  CTBXFUN   Autor  Marcos S. Lobo       Data   11/14/06   
͹
Desc.     Recalcula os totais no rodape da tela de lancamento Mod.2   
                                                                      
͹
Uso        AP(ctba102 e ctba105)                                     
ͼ


*/
Function CtRecRdPe()

Local nRecTmp := TMP->(Recno())

aTotRdpe := {{0,0,0,0},{0,0,0,0}}

TMP->(DbGoTop())
While !TMP->(Eof())
	If !TMP->CT2_FLAG
		CTB102Exibe(TMP->CT2_VALOR,0,TMP->CT2_DC,"")
	Endif
	TMP->(DbSkip())
EndDo

TMP->(DbGoTo(nRecTmp))

Return

/*


Ŀ
Funo     CTBXFUN_V  Autor  Marcos V. Ferreira    Data  25/04/06 
Ĵ
Descrio  Funcao utilizada para verificar a ultima versao do fonte   
			  CTBXFUN aplicado no rpo do cliente, verificando assim a    
			  necessidade de uma atualizacao neste fonte.		    	  
Ĵ
 Uso       EST/PCP/FAT/COM	                                          
ٱ


*/
Function CTBXFUN_V
Local nRet := 20060425 // 25 de abril de 2006
Return nRet


/*/


Ŀ
Funcao     IfDefTopCTB  Autor  Eduardo Nunes Cirqueira  Data  19/10/07 
Ĵ
Descrio  Identifica se e TOP ou nao. Utilizada nos onde nao pode-se usar 
           a diretiva #IFDEFTOP (por exemplo, manad.ini, norma086.ini, etc)
Ĵ
Sintaxe    IfDefTopCTB()                                                   
Ĵ
Retorno    Logico                                                          
Ĵ
Uso        Generico                                                        
Ĵ
Parametros                                                                 
ٱ


/*/
Function IfDefTopCTB()

Return(.T.)

/*/


Ŀ
Funcao     CtbTpSald    Autor  Totvs                    Data  02/09/08 
Ĵ
Descrio  Permite a multipla selecao dos tipos de saldos                  
Ĵ
Uso        Generico                                                        
ٱ


/*/
Function CtbTpSld( cPreSel, cSepara, lVisual )
	Local aReturn		:= {}
	Local nInc			:= 0

	Private nTam		:= 0
	Private aCat		:= {}
	Private MvRet		:= cPreSel
	Private MvPar		:= ""
	Private cTitulo		:= ""
	Private MvParDef	:= ""

	Default cPreSel		:= ""
	Default cSepara		:= "/"
	Default lVisual		:= .T.

	#IFDEF WINDOWS
		oWnd := GetWndDefault()
	#ENDIF

	//Tratamento para carregar variaveis da lista de opcoes
	nTam	:= 1
	cTitulo := "Saldos Contabeis"
	SX5->( DbSetOrder( 1 ) )
	SX5->( DbSeek( xFilial( "SX5" ) + "SL" ) )
	While SX5->( !Eof() ) .And. AllTrim( SX5->X5_TABELA ) == "SL"
		MvParDef += AllTrim( SX5->X5_CHAVE )

		If __LANGUAGE == "PORTUGUESE"
			aAdd( aCat, AllTrim( SX5->X5_CHAVE ) + " - " + AllTrim( SX5->X5_DESCRI ) )
		ElseIf __LANGUAGE == "SPANISH"
			aAdd( aCat, AllTrim( SX5->X5_CHAVE ) + " - " + AllTrim( SX5->X5_DESCSPA ) )
		ElseIf __LANGUAGE == "ENGLISH"
			aAdd( aCat, AllTrim( SX5->X5_CHAVE ) + " - " + AllTrim( SX5->X5_DESCENG ) )
		Endif

		SX5->( DbSkip() )
	End
	MvPar := PadR( AllTrim( StrTran( MvRet, cSepara, "" ) ), Len( aCat ) )

	//Executa funcao que monta tela de opcoes
	AdmOpcoes( @MvPar, cTitulo, aCat, MvParDef, 12, 49, .F., nTam, Len( aCat ),,,,,,,, lVisual )

	//Tratamento para separar retorno com barra "/"
	For nInc := 1 to Len( MvPar )
		If !( SubStr( MvPar, nInc, 1 ) $ " |*" )
			aAdd( aReturn, SubStr( MvPar, nInc, 1 ) )
		EndIf
	Next

Return aReturn

/*/


Ŀ
Program   CTBJobsStart  Autor  Totvs               Data  03.12.08 
Ĵ
Descrio  Verifica se podera usar o JOB do CTB                       
Ĵ
Sintaxe    CTBJobsStart()                                             
Ĵ
Uso        Generico                                                   
ٱ


/*/
Function CTBJobsStart()

If LockByName( "JOB_CTB_SALDO2_" + cEmpAnt )
	UnlockByName( "JOB_CTB_SALDO2_" + cEmpAnt)
	StartJob( "CTBSLDJOB2", GetEnvServer(), .F., { cEmpAnt, cFilAnt, cUserName, .F. } )
Endif

UnlockByName( "JOB_CTB_SALDO2_" + cEmpAnt)

Return

//-------------------------------------------------------------------
/*{Protheus.doc} IsCtbJob
Verifica se podera usar o JOB do CTB
A funo j possui cache de execuo.

@author Alvaro Camillo Neto

@version P12
@since   20/02/2014
@return  Nil
@obs
*/
//-------------------------------------------------------------------
Function IsCtbJob()

Local oDASchedule := Nil //chama o objeto do schedule
Local aSchd:={}
Local aEmpFil	:= {}
Local nX		:= 0
Local nY		:= 0
Local cEnv 		:= ""
Local cEmpFil	:= ""
Local nAt		:= 0

If __aIsCtbJob == Nil
	__aIsCtbJob := {}

	oDASchedule := FWDASchedule():New() //chama o objeto do schedule
	aSchd:=oDASchedule:readSchedules() //como voce no sabe quem , tem que ler todos

	If Len(aSchd) <= 0
		__aIsCtbJob := {{"","",.F.}}
		If __lConoutR
			ConoutR( "CtbJob| LIBAGENT" + STR0028) // "O agente de schedule est desativado, verifique configurao."
		EndIf
	Endif

	For nX:=1 to len(aSchd)
		If Alltrim(aSchd[nX]:GetFunction())== 'CTBA193'

			cEmpFil := AllTrim(aSchd[nX]:getEmpFil())

			While !Empty(cEmpFil)
				If ( nAt := At( ";", cEmpFil ) ) > 0
					aAdd( aEmpFil, Subs( cEmpFil, 1, nAt-1 ) )
					cEmpFil := Subs( cEmpFil, nAt+1 )
				EndIf
			EndDo

			If Len(aEmpFil) > 0
				// Grava novos registros selecionados
				For nY := 1 To Len(aEmpFil)
					aadd(__aIsCtbJob, {alltrim(aSchd[nX]:getEnv()),Alltrim(aEmpFil[nY]),(aSchd[nX]:GetStatus()==SCHD_ACTIVE)})
				Next nX
			Else
				aadd(__aIsCtbJob, {Alltrim(aSchd[nX]:getEnv()),(cEmpAnt+"/"+cFilAnt),(aSchd[nX]:GetStatus()==SCHD_ACTIVE)})
			Endif
		Endif
	Next
Endif

// recupero o Environment a ser utilizado no jobctb
cEnv 	:= GetEnvServer()
nPosJob := AScan(__aIsCtbJob,{|x| x[1] == cEnv .And. x[2] == Alltrim(cEmpAnt+"/"+cFilAnt)})

If nPosJob > 0
	lRetorno := __aIsCtbJob[nPosJob,3]
Else
	lRetorno := .F.
	If __lConoutR
		ConoutR( "CtbJob| LIBSERV: " + STR0029 ) // "O Servio de Schedule est desativado, verifique configurao."
	EndIf
Endif

If __lConoutR
	ConoutR( "CtbJob| Verificao da empresa: " + cEmpAnt + " Environment: " + cEnv + " - " + iif(lRetorno, " JOB HABILITADO!" , " JOB NO HABILITADO!" ))
Endif

Return lRetorno

/*


Ŀ
Funo    CTBNomeVis  Autor  Marcelo Akama            Data  10/08/09 
Ĵ
Descricao  Funcao para retornar o nome da visao gerencial                
Ĵ
 Uso       Generico                                                      
ٱ


*/
Function CTBNomeVis( cCodigo )
Local aArea		:= GetArea()
Local aAreaCVE  := CVE->(GetArea())
Local cRet		:= ""

If !Empty(cCodigo)
	DbSelectArea( "CVE" )
	CVE->( DbSetOrder( 1 ) )

	If CVE->( DbSeek( xFilial( "CVE" ) + cCodigo ) )
		cRet := AllTrim(CVE->CVE_DESCRI)
	EndIf
EndIf

RestArea(aAreaCVE)
RestArea(aArea)

Return cRet

/*/


Ŀ
Program   CtbExibe   Autor  Pilar S. Albaladejo    Data  24.07.00 
Ĵ
Descrio  Exibe descricao da Conta no Lcto Contabil                  
Ĵ
Sintaxe   CtbExibe(cConta,cTipo,oDescDeb,oDescCrd,lRet)               
Ĵ
Retorno    .T. 		                                                  
Ĵ
Uso        Generico 	                                              
Ĵ
Parametros ExpC1 = Conta contabil                                     
           ExpC2 = Tipo do Lancamento                                 
           ExpO1 = Objeto Descricao Conta Debito                      
           ExpO2 = Objeto Descricao Conta Credito                     
           ExpL1 = .T. -> Descricao da Conta / .F.-> Space(nTamConta) 
ٱ


/*/
Function CTBExibe(cConta,cTipo,oDescDeb,oDescCrd,lRet)

If cTipo == "1"
	CTB_Exibe(cConta,cTipo,"CT1"/*cAliasEnt*/,"CT1_DESC01"/*cCampo*/,{||CT1->CT1_DESC01}/*bCampo*/,oDescDeb/*oObjDesc*/,lRet)
ElseIf cTipo == "2"
	CTB_Exibe(cConta,cTipo,"CT1"/*cAliasEnt*/,"CT1_DESC01"/*cCampo*/,{||CT1->CT1_DESC01}/*bCampo*/,oDescCrd/*oObjDesc*/,lRet)
EndIf

Return .T.

/*/


Ŀ
Program   CtbExibeCC Autor  Simone Mie Sato        Data  31.01.01 
Ĵ
Descrio  Exibe descricao do Centro de Custo     		              
Ĵ
Sintaxe    CtbExibeCC(cCusto,cTipo,oDescCCD,oDescCCC,lRet)            
Ĵ
Retorno    .T. 		                                                  
Ĵ
Uso        Generico                                                   
Ĵ
Parametros ExpC1 = Centro de Custo                                    
           ExpC2 = Tipo do Lancamento                                 
           ExpO1 = Objeto Descricao CC Debito 	                      
           ExpO2 = Objeto Descricao CC Credito    		              
           ExpL1 = .T. -> Descricao do CC    / .F.-> Space(nTamConta) 
ٱ


/*/
Function CTBExibeCC(cCusto,cTipo,oDescCCD,oDescCCC,lRet)
If cTipo == "1"
	CTB_Exibe(cCusto,cTipo,"CTT"/*cAliasEnt*/,"CTT_DESC01"/*cCampo*/,{||CTT->CTT_DESC01}/*bCampo*/,oDescCCD/*oObjDesc*/,lRet)
ElseIf cTipo == "2"
	CTB_Exibe(cCusto,cTipo,"CTT"/*cAliasEnt*/,"CTT_DESC01"/*cCampo*/,{||CTT->CTT_DESC01}/*bCampo*/,oDescCCC/*oObjDesc*/,lRet)
EndIf

Return .T.

/*/


Ŀ
Programa  CtbExibeIt Autor  Simone Mie Sato        Data  31.01.01 
Ĵ
Descrio  Exibe descricao do Item Contabil       		              
Ĵ
Sintaxe   CTBExibeIt(cItem,cTipo,odescItd,oDescItC,lRet)	          
Ĵ
Retorno    .T. 		                                                  
Ĵ
Uso        Generico 	                                              
Ĵ
Parametros ExpC1 = Item Contabil                                      
           ExpC2 = Tipo do Lancamento                                 
           ExpO1 = Objeto Descricao Item Debito                       
           ExpO2 = Objeto Descricao Item Credito  		              
           ExpL1 = .T. -> Descricao do Item  / .F.-> Space(nTamConta) 
ٱ


/*/
Function CTBExibeIt(cItem,cTipo,oDescItD,oDescItC,lRet)

If cTipo == "1"
	CTB_Exibe(cItem,cTipo,"CTD"/*cAliasEnt*/,"CTD_DESC01"/*cCampo*/,{||CTD->CTD_DESC01}/*bCampo*/,oDescItD/*oObjDesc*/,lRet)
ElseIf cTipo == "2"
	CTB_Exibe(cItem,cTipo,"CTD"/*cAliasEnt*/,"CTD_DESC01"/*cCampo*/,{||CTD->CTD_DESC01}/*bCampo*/,oDescItC/*oObjDesc*/,lRet)
EndIf

Return .T.

/*/


Ŀ
Programa  CtbExibeCV Autor  Simone Mie Sato        Data  31.01.01 
Ĵ
Descrio  Exibe descricao da Clase de Valores    		              
Ĵ
Sintaxe   CtbExibeCv(cClVl,Ctipo,oDescCvd,oDescCVC,lRet )             
Ĵ
Retorno    .T. 		                                                  
Ĵ
Uso        Generico                                                   
Ĵ
Parametros ExpC1 = Codigo da Classe de Valor                          
           ExpC2 = Tipo do Lancamento                                 
           ExpO1 = Objeto Descricao Classe de Valor Debito            
           ExpO2 = Objeto Descricao Classe de Valor Credito           
           ExpL1 = .T. -> Descricao da CV    / .F.-> Space(nTamConta) 
ٱ


/*/
Function CTBExibeCV(cClVl,cTipo,oDescCVD,oDescCVC,lRet)

If cTipo == "1"
	CTB_Exibe(cClVl,cTipo,"CTH"/*cAliasEnt*/,"CTH_DESC01"/*cCampo*/,{||CTH->CTH_DESC01}/*bCampo*/,oDescCVD/*oObjDesc*/,lRet)
ElseIf cTipo == "2"
	CTB_Exibe(cClVl,cTipo,"CTH"/*cAliasEnt*/,"CTH_DESC01"/*cCampo*/,{||CTH->CTH_DESC01}/*bCampo*/,oDescCVC/*oObjDesc*/,lRet)
EndIf

Return .T.

/*/


Ŀ
Programa  CTB_Exibe  Autor  Paulo Carnelossi           Data  01/09/09 
Ĵ
Descrio  Exibe descricao das entidades        		                  
Ĵ
Sintaxe    CTB_Exibe(cCodEnt,cTipo,cAliasEnt,cCampo,bCampo,oObjDesc,lRet) 
Ĵ
Retorno    .T. 		                                                      
Ĵ
Uso        Generico  (conversao das diversas CTBExibe()                   
Ĵ
Parametros ExpC1 = Codigo da Entidade                                     
           ExpC2 = Tipo do Lancamento                                     
           ExpC3 = cAliasEnt-Alias da Entidade                            
           ExpC4 = Campo                                                  
           ExpB1 = Bloco de codigo para o campo                           
           ExpO1 = Objeto Descricao                                       
           ExpL1 = .T. -> Descricao     / .F.-> Space(nTam)               
ٱ


/*/
Function CTB_Exibe(cCodEnt, cTipo, cAliasEnt, cCampo, bCampo, oObjDesc, lRet)
Local cDesc := CriaVar(cCampo)
Local nTam	:= Len(cDesc)

If !Empty(cCodEnt) .And. lRet
	cDesc := Eval(bCampo)
Else
	cDesc := Space(nTam)
EndIf

oObjDesc:SetText(OemToAnsi(cDesc))

Return .T.

/*/


Ŀ
Program   CtbSoma1Li  Autor  Simone Mie Sato       Data  05.12.03 
Ĵ
Descrio Converte o conteudo do param. MV_NUMMAN com Soma1.          
Ĵ
Sintaxe   CtbSoma1Li()                                                
Ĵ
Retorno    .T.					                                      
Ĵ
Uso       Generico				                                      
ٱ


/*/
Function CtbSoma1Li()

Local aSaveArea	:= GetArea()
Local nDif		:= 0
Local nNumMan	:= GetMv("MV_NUMMAN")
Local nTamParam	:= 0
Local nDifParam	:= 0
Local cNumLin	:= ""
Local nCont		:= 0

nDif  := nNumMan - 999

If nNumMan	> 999
	If nDif > 0
		cNumLin := "999"
		For nCont := 1 To nDif
			cNumLin := Soma1(cNumLin)
		Next
	Endif
Else
	cNumLin	:= Alltrim(Str(nNumMan))
	nTamParam	:= Len(cNumLin)
	nDifParam	:= 3 - nTamParam
	If nDifParam > 0
		cNumLin	:= ""
		For nCont	:= 1 to nDifParam
			cNumLin	+= "0"
    	Next
	    cNumLin	+= Alltrim(Str(nNumMan))
	EndIf
EndIf

RestArea(aSaveArea)

Return(cNumLin)

/*


ͻ
Programa  CTBA105   Autor  Microsiga            Data   08/04/09   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                         
ͼ


*/

Function CtbLinMax(nMv_NumLin)
Local nRet := 0

If nMv_NumLin >= 35658  //limite estabelecido em razao do tamanho campo CT2_LINHA  = 3 e utilizar a funcao Soma1() para incremento
	nRet := 35657
Else
	nRet := nMv_NumLin
EndIf

Return(nRet)

/*


ͻ
Programa  CTBRetaSLDAutor  Marcos S. Lobo       Data   09/12/06   
͹
Desc.     Retorna array com os tipos de saldo utilizados no SIGACTB.  
                                                                      
͹
Uso        AP - Reprocessamento CTB                                   
ͼ


*/
Function CtbRetaSLD()
Local aTpSaldos := {}
Local aAreaOri	:= GetArea()
Local aAreaSX5	:= {}
Local cFilialX5

dbSelectArea( "SX5" )
cFilialX5 := xFilial( "SX5" )

aAreaSX5 := GetArea()
dbSetOrder( 1 )

If SX5->( MsSeek( cFilialX5 + "SL" , .F. ))

	While SX5->X5_FILIAL == cFilialX5 .And. SX5->X5_TABELA = "SL"
		Aadd( aTpSaldos, Left( SX5->X5_CHAVE, 1 ))

		SX5->( DbSkip() )
	EndDo

Else
	aTpSaldos := { "1", "2", "3", "4" }
Endif

RestArea( aAreaSX5 )
RestArea( aAreaOri )

Return aTpSaldos


/*


ͻ
Programa  CTBShowLisAutor  Marcos S. Lobo       Data   10/25/06   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtbShowLst(cTitle,aItens)

Local cRet		:= ""
Local oDlgList
Local oList1
Local oSBtn2
DEFAULT cTitle  := ""

oDlgList := MSDIALOG():Create()
oDlgList:cName := "oDlgList"
oDlgList:cCaption := cTitle
oDlgList:nLeft := 0
oDlgList:nTop := 0
oDlgList:nWidth := 365
oDlgList:nHeight := 352
oDlgList:lShowHint := .F.
oDlgList:lCentered := .T.

oList1 := TLISTBOX():Create(oDlgList)
oList1:cName := "oList1"
oList1:cCaption := ""
oList1:nLeft := 11
oList1:nTop := 12
oList1:nWidth := 338
oList1:nHeight := 273
oList1:lShowHint := .F.
oList1:lReadOnly := .F.
oList1:Align := 0
oList1:lVisibleControl := .T.
oList1:nAt := 0
oList1:aItems := aItens

oSBtn2 := SBUTTON():Create(oDlgList)
oSBtn2:cName := "oSBtn2"
oSBtn2:cCaption := "Ok"
oSBtn2:nLeft := 296
oSBtn2:nTop := 294
oSBtn2:nWidth := 52
oSBtn2:nHeight := 22
oSBtn2:lShowHint := .F.
oSBtn2:lReadOnly := .F.
oSBtn2:Align := 0
oSBtn2:lVisibleControl := .T.
oSBtn2:nType := 1
oSBTn2:bAction:= {|| oDlgList:End() }

oDlgList:Activate()

Return

/*


ͻ
Programa   CtbDescEnt     Autor  Gustavo Henrique  Data  30/10/06 
͹
Descricao  Retorna a descricao do codigo de uma entidade contabil na  
           moeda passada como parametro.                              
͹
Parametros cCodEnt   - Codigo para procura na entidade contabil       
           cMoeda    - Moeda para identificar a descricao da entidade 
           cAliasEnt - Alias da entidade para pesquisa da descricao   
͹
Retorno    cRet - Descricao do codigo da entidade contabil passado    
                  no parametro cCodEnt.                               
͹
Uso        Contabilidade Gerencial                                    
ͼ


*/
Function CtbDescEnt( cCodEnt, cAliasEnt, cMoeda )

Local aArea 	:= GetArea()
Local aAreaEnt	:= (cAliasEnt)->(GetArea())
Local cCpoDesc	:= ""
Local cRet		:= ""

DEFAULT cCodEnt		:= ""
DEFAULT cMoeda		:= "01"
DEFAULT cAliasEnt	:= "CT1"

If cAliasEnt $ "CT1/CTT/CTD/CTH"

	If ValType(cCodEnt) == "N"
		cCodEnt := ALLTRIM(STR(cCodEnt))
	EndIf

	If ValType(cMoeda) == "N"
		cCodEnt := ALLTRIM(STR(cMoeda,2))
	EndIf

	(cAliasEnt)->( dbSetOrder(1) )
	If (cAliasEnt)->( MsSeek( xFilial(cAliasEnt) + cCodEnt, .F. ) )
		cCpoDesc := cAliasEnt + "_DESC" + cMoeda
		cRet := (cAliasEnt)->(CtbDescMoeda(cCpoDesc))
	EndIf

EnDif

RestArea( aAreaEnt )
RestArea( aArea )

Return( cRet )

/*


ͻ
Programa  GetRngFil Autor  Renato F. Campos     Data   08/25/08   
͹
Desc.      Retorna a expresso correta                                
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function GetRngFil( xSelFil , cAlias, lTmpFil, cTmpFil, nLimTmp, lFilOrg )
Local cRetorno 		:= ""
Local aArea			:= GetArea()
Local nX			:= 0
Local aStruct 		:= {}
Local nTamFil 		:= CtbTamSXG("033",2)  //grupo ; tamanho padrao
Local lGestao		:= Iif( lFWCodFil, ( LEN(CT2->CT2_FILIAL) > 2 ), .F. )	// Indica se usa Gestao Corporativa
Local aModoComp 	:= {}
Local lExclusivo 	:= .F.
Local cFilCpy
Local cAtualxFil
Local nAt
Local cNameTbl 		:= "" //Nome da tabela temporria

Default lTmpFil := .F.
Default nLimTmp := 50
Default lFilOrg := .F.

If lFWCodFil .And. lGestao
	aAdd(aModoComp, FWModeAccess(cAlias,1) )
	aAdd(aModoComp, FWModeAccess(cAlias,2) )
	aAdd(aModoComp, FWModeAccess(cAlias,3) )
	lExclusivo := Ascan(aModoComp, 'E') > 0
Else
	dbSelectArea(cAlias)
	lExclusivo := !Empty(xFilial(cAlias))
EndIf

If Valtype(xSelFil) == "A"
	If lExclusivo .Or.; //cAlias em modo exclusivo
	   lFilOrg // Tratamento para FILIAL DE ORIGEM
		If lTmpFil .And. Len(xSelFil) > nLimTmp //50 //SOMENTE ACIMA DE 50 FILIAIS CRIA ARQUIVO TEMPORARIO NO BANCO

			If __aRealTempTable == Nil
				__aRealTempTable := {}
			EndIf

			If cTmpFil == NIL .or. Empty(cTmpFil)
				cTmpFil:= GetNextAlias() // Substituicao do CriaTrab para FWTemporaryTable
			Endif

			If Select(cTmpFil) > 0
				dbSelectArea(cTmpFil)
				dbCloseArea()
			EndIf

			Aadd( __aRealTempTable, { cTmpFil, FWTemporaryTable():New( cTmpFil ) } )
			nAt := Len( __aRealTempTable )

			aStruct:= {}
			//--------------------------
			//Monta os campos da tabela
			//--------------------------
			AADD(aStruct,{ "TMPFIL", "C", nTamFil, 0 } )

			__aRealTempTable[nAT][2]:SetFields( aStruct )
			__aRealTempTable[nAT][2]:AddIndex("1", {"TMPFIL"} )

			//------------------
			//Criao da tabela
			//------------------
			__aRealTempTable[nAT][2]:Create()

			If lFWCodFil .And. lGestao
				cFilCpy := cFilAnt
				//laco para percorrer todas as filiais selecionadas
				For nX := 1 to Len(xSelFil)
					cFilAnt := xSelFil[nX]
					dbSelectArea(cAlias)
					cAtualxFil := IIF( lFilOrg, cFilAnt, xFilial(cAlias) )
					dbSelectArea(cTmpFil)
					//popula arquivo temporario no banco
					If !Empty(cAtualxFil) .And. !dbSeek(cAtualxFil)
						RecLock(cTmpFil, .T.)
						(cTmpFil)->TMPFIL := cAtualxFil
						MsUnlock()
					EndIf
				Next nX
				//restaura empresa/filial posicionada antes do laco
				cFilAnt := cFilCpy
			Else
				//popula arquivo temporario no banco
				For nX := 1 to Len(xSelFil)
					RecLock(cTmpFil, .T.)
					(cTmpFil)->TMPFIL := xSelFil[nX]
					MsUnlock()
				Next nX
			EndIf
			//Banco de dados MSSQL retirar a extenso dbo.
			If Upper(TcGetDb()) == "MSSQL7"
				cNameTbl := StrTran (__aRealTempTable[nAT][2]:GetRealName(),'dbo.')
			Else
				cNameTbl := __aRealTempTable[nAT][2]:GetRealName()
			EndIf

			cRetorno := "IN ( SELECT TMPFIL FROM " + cNameTbl + " ) "

		ElseIf Len(xSelFil) > 1
			If lFWCodFil .And. lGestao
				cFilCpy := cFilAnt
				For nX := 1 to Len(xSelFil)
					cFilAnt := xSelFil[nX]
					dbSelectArea(cAlias)
					cAtualxFil := IIF( lFilOrg, cFilAnt, xFilial(cAlias) )
					cRetorno += cAtualxFil + "\"
				Next nX
				cRetorno := Left(cRetorno, Len(cRetorno) - 1 )
				cRetorno := "IN " + FormatIn(cRetorno,"\") + " "
				cFilAnt := cFilCpy
			Else
				For nX := 1 to Len(xSelFil)
					cRetorno += xSelFil[nX] + "\"
				Next nX
				cRetorno := Left(cRetorno, Len(cRetorno) - 1 )
				cRetorno := "IN " + FormatIn(cRetorno,"\") + " "
			EndIf
		Else
			If lFWCodFil .And. lGestao
				cFilCpy := cFilAnt
				If Len(xSelFil) > 0
					cFilAnt := xSelFil[1]
				EndIf
				dbSelectArea(cAlias)
				cAtualxFil := IIF( lFilOrg, cFilAnt, xFilial(cAlias) )
				cRetorno := " = '" + cAtualxFil + "' "
				cFilAnt := cFilCpy
			Else
				If Len(xSelFil) > 0
					cRetorno := " = '" + xSelFil[1] + "' "
				Else
					cRetorno := " = '" + xFilial(cAlias) + "' "
				EndIf
			EndIf
		EndIf
	Else
		//cAlias em modo compartilhado
		dbSelectArea(cAlias)
		cRetorno := " = '" + xFilial(cAlias) + "' "
	EndIf

Else
	cRetorno := " = '" + xFilial(cAlias,xSelFil) + "' "
EndIf

RestArea(aArea)

Return cRetorno

/*


ͻ
Programa  CtbTmpErase  Autor  Microsiga        Data   02/06/11   
͹
Desc.      Deletar tabela temporaria do banco que contem as filiais   
           utilizadas nas querys criado na funcao GetRngFil           
͹
Uso        AP                                                         
ͼ


*/
Function CtbTmpErase(cTmpFil)
Local aArea := GetArea()
Local nAT

If ValType(__aRealTempTable)=="A" .And. (nAt := Ascan(__aRealTempTable, {|x| x[1]==cTmpFil })) > 0

	__aRealTempTable[nAT][2]:Delete()
	__aRealTempTable[nAT][2] := Nil

	ADel(__aRealTempTable, nAT)
	ASize(__aRealTempTable,Len(__aRealTempTable)-1)

Else

	If cTmpFil <> NIL .And. Valtype(cTmpFil) == "C" .And. !Empty(cTmpFil) .AND. Select(cTmpFil) > 0
		dbSelectArea(cTmpFil)
		dbCloseArea()
		MsErase(cTmpFil)
		Sleep(100)
	EndIf

EndIf

RestArea(aArea)

Return
/*


ͻ
Programa  CW0Chav   Autor  Alvaro Camillo Neto  Data   19/11/09   
͹
Desc.      Retorna a primeira chave da tabela que contem a descrio  
           passada.                                                   
͹
Uso        AP                                                        
ͼ


*/
Function CW0Chav( cTabela,cDesc,cMoeda,cDefault )
Local cChave	:= ""
Local aArea		:= GetArea()
Local cCpoDesc := "CW0_DESC"
Default cMoeda	:= "01"
Default cDefault	:= ""

cCpoDesc+= Alltrim( cMoeda )

dbSelectArea("CW0")
CW0->( dbSetOrder( 1 ) ) // CW0_FILIAL + CW0_TABELA + CW0_CHAVE
CW0->( MsSeek( xFilial( "CW0" ) + cTabela ) )

While CW0->( CW0_FILIAL + CW0_TABELA ) == xFilial( "CW0" ) + cTabela .And. CW0->( !EOF() )
	If CW0->(&(cCpoDesc)) $ cDesc .Or. cDesc $ CW0->(&(cCpoDesc))
		cChave := CW0->CW0_CHAVE
		Exit
	EndIf
	CW0->( dbSkip() )
EndDo

cChave := IIF( !Empty(cChave),cChave,cDefault  )

RestArea(aArea)
Return cChave

/*


ͻ
Programa  CW0Desc   Autor  Alvaro Camillo Neto  Data   19/11/09   
͹
Desc.      Retorna o conteudo relacionado a chave passada da tabela   
           auxiliar                                                   
͹
Uso        AP                                                         
ͼ


*/
Function CW0Desc( cTabela,cChave,cMoeda )
Local cDesc	:= ""
Local aArea		:= GetArea()
Local cCpoDesc := "CW0_DESC"
Default cMoeda	:= "01"

cCpoDesc+= Alltrim( cMoeda )


dbSelectArea("CW0")
CW0->( dbSetOrder( 1 ) ) // CW0_FILIAL + CW0_TABELA + CW0_CHAVE
If CW0->( MsSeek( xFilial( "CW0" ) + cTabela + cChave ) )
	cDesc := CW0->(&(cCpoDesc))
EndIf


RestArea(aArea)
Return cDesc


/*


ͻ
Programa  CW0Desc   Autor  Alvaro Camillo Neto  Data   19/11/09   
͹
Desc.      Retorna o nome da tabela                                   
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function CW0Tab( cTabela, cMoeda )
Local cDesc	:= ""
Local aArea		:= GetArea()
Local cCpoDesc := "CW0_DESC"
Default cMoeda	:= "01"

cCpoDesc+= Alltrim( cMoeda )

dbSelectArea("CW0")
CW0->( dbSetOrder( 1 ) ) // CW0_FILIAL + CW0_TABELA + CW0_CHAVE
If CW0->( MsSeek( xFilial( "CW0" ) + "00" + cTabela ) )
	cDesc := CW0->(&(cCpoDesc))
EndIf


RestArea(aArea)
Return cDesc

/*


ͻ
Programa  CW0CONS   Autor  Microsiga           Fecha   02/26/10   
͹
Desc.                                                                 
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function CW0CONS(cTabela,cMoeda)
	Local cQuery	:= ""
	Local cAliasCW0	:= ""
	Local cDescCW0	:= ""
	Local cFilCW0	:= ""
	Local cCpoCW0	:= ""
	Local cDesc		:= ""
	Local nItem		:= 0
	Local xRet
	Local aArea		:= {}
	Local aAreaCW0	:= {}
	Local aItens	:= {}
	Local aScrRes	:= {}
	Local oDlgCW0
	Local oBrwCW0
	//Paineis
	Local oPnlTopo
	Local oPnlEsq
	Local oPnlDir
	Local oPnlBase
	Local oPnlCons
	Local oPnlCons1
	Local oPnlBot
	Local oSep0
	Local oSep1
	Local oSep2
	Local oSep3
	Local oSep4
	Local oSep5
	//Botoes
	Local oBtnSair
	Local oBtnOk
	Local oBtnPesq
	//variaveis
	Local oDesc
	Local oSayDesc

	Default cMoeda	:= "01"

	aArea := GetArea()
	cFilCW0 := xFilial("CW0")
	If CW0->(DbSeek(cFilCW0 + "00" + PadR(cTabela,TamSX3("CW0_CHAVE")[1])))
		cCpoCW0 := "CW0_DESC" + cMoeda
		cDescCW0 := CW0->(&cCPOCW0)
		cQuery := "select R_E_C_N_O_,CW0_CHAVE," + cCpoCW0 + " W0DESC from " + RetSqlName("CW0")
		cQuery += " where CW0_FILIAL = '" + xFilial("CW0") + "'"
		cQuery += " and CW0_TABELA = '" + PadR(cTabela,TamSX3("CW0_TABELA")[1]) + "'"
		cQuery += " and D_E_L_E_T_=''"
		cAliasCW0 := GetNextAlias()
		cQuery := ChangeQuery(cQuery)
		dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasCW0,.T.,.T.)
		dbSelectArea(cAliasCW0)
		(cAliasCW0)->(DbGoTop())
		While !((cAliasCW0)->(Eof()))
			Aadd(aItens,{(cAliasCW0)->CW0_CHAVE,(cAliasCW0)->W0DESC,(cAliasCW0)->R_E_C_N_O_})
			(cAliasCW0)->(DbSkip())
		Enddo
		dbSelectArea(cAliasCW0)
		DbCloseArea()
		If !Empty(aItens)
			cDesc := Space(CW0->(TamSX3(cCpoCW0)[1]))
			aScrRes := MsAdvSize(.F.,.F.,300)
			oDlgCW0 := TDialog():New(aScrRes[7],0,aScrRes[6]-250,aScrRes[5]-450,AllTrim(cDescCW0),,,,,,,,,.T.,,,,,)
				oPnlEsq := TPanel():New(01,01,,oDlgCW0,,,,,,5,5,.F.,.F.)
					oPnlEsq:Align := CONTROL_ALIGN_LEFT
					oPnlEsq:nWidth := 10
				oPnlDir := TPanel():New(01,01,,oDlgCW0,,,,,,5,5,.F.,.F.)
					oPnlDir:Align := CONTROL_ALIGN_RIGHT
					oPnlDir:nWidth := 10
				oPnlBase := TPanel():New(01,01,,oDlgCW0,,,,,,5,30,.F.,.F.)
					oPnlBase:Align := CONTROL_ALIGN_BOTTOM
					oPnlBase:nHeight := 10
				oPnlTopo := TPanel():New(01,01,,oDlgCW0,,,,,,5,30,.F.,.F.)
					oPnlTopo:Align := CONTROL_ALIGN_TOP
					oPnlTopo:nHeight := 10
				oPnlCons := TPanel():New(01,01,,oDlgCW0,,,,,,5,30,.F.,.F.)
					oPnlCons:Align := CONTROL_ALIGN_TOP
					oPnlCons:nHeight := 40
					oPnlCons1 := TPanel():New(01,01,,oPnlCons,,,,,,5,30,.F.,.F.)
						oPnlCons1:Align := CONTROL_ALIGN_ALLCLIENT
						@00,00 MSGET oDesc VAR cDesc SIZE 5,100 PIXEL OF oPnlCons1
							oDesc:Align := CONTROL_ALIGN_BOTTOM
							oDesc:nHeight := 20
						oSayDesc := TSay():New(0,0,{|| CW0->(RetTitle(cCpoCW0))},oPnlCons1,,,,,,.T.,,,10,10)
							oSayDesc:Align := CONTROL_ALIGN_TOP
							oSayDesc:nHeight := 20
					oSep4 := TPanel():New(01,01,,oPnlCons,,,,,,5,30,.F.,.F.)
						oSep4:Align := CONTROL_ALIGN_RIGHT
						oSep4:nWidth := 10
					oSep5 := TPanel():New(01,01,,oPnlCons,,,,,,5,30,.F.,.F.)
						oSep5:Align := CONTROL_ALIGN_LEFT
						oSep5:nWidth := 10
					oPnlBot := TPanel():New(01,01,,oPnlCons,,,,,,5,30,.F.,.F.)
						oPnlBot:Align := CONTROL_ALIGN_RIGHT
						oPnlBot:nWidth := 100
					oPnlBot1 := TPanel():New(01,01,,oPnlBot,,,,,,5,30,.F.,.F.)
						oPnlBot1:Align := CONTROL_ALIGN_BOTTOM
						oPnlBot1:nHeight := 20
						oBtnPesq := TButton():New(0,0,"Pesquisar",oPnlBot1,{|| },30,10,,,,.T.,,"",,,,)
							oBtnPesq:Align := CONTROL_ALIGN_RIGHT
							oBtnPesq:nWidth := 80
				oSep3 := TPanel():New(01,01,,oDlgCW0,,,,,,5,30,.F.,.F.)
					oSep3:Align := CONTROL_ALIGN_TOP
					oSep3:nHeight := 10
				oPnlBotoes := TPanel():New(01,01,,oDlgCW0,,,,,,5,30,.F.,.F.)
					oPnlBotoes:Align := CONTROL_ALIGN_BOTTOM
					oPnlBotoes:nHeight := 20
					oSep0 := TPanel():New(01,01,,oPnlBotoes,,,,,,5,30,.F.,.F.)
						oSep0:Align := CONTROL_ALIGN_TOP
						oSep0:nHeight := 5
					oSep1 := TPanel():New(01,01,,oPnlBotoes,,,,,,5,30,.F.,.F.)
						oSep1:Align := CONTROL_ALIGN_RIGHT
					oBtnSair := TButton():New(0,0,"Cancelar",oPnlBotoes,{|| nItem := 0,oDlgCW0:End()},30,10,,,,.T.,,"",,,,)
						oBtnSair:Align := CONTROL_ALIGN_RIGHT
					oSep2 := TPanel():New(01,01,,oPnlBotoes,,,,,,5,30,.F.,.F.)
						oSep2:Align := CONTROL_ALIGN_RIGHT
					oBtnOk := TButton():New(0,0,"Selecionar",oPnlBotoes,{|| nItem := oBrwCW0:nAt,oDlgCW0:End()},30,10,,,,.T.,,"",,,,)
						oBtnOk:Align := CONTROL_ALIGN_RIGHT
				oBrwCW0 := TCBrowse():New(0,0,100,100,,,,oBrwCW0,,,,,,,,,,,,.T.,"",.T.,{|| .T.},,,,)
				oBrwCW0:AddColumn(TCColumn():New(CW0->(RetTitle("CW0_CHAVE")),{|| aItens[oBrwCW0:nAt,1]},,,,"LEFT",15,.F.,.F.,,,,,))
				oBrwCW0:AddColumn(TCColumn():New(CW0->(RetTitle(cCpoCW0)),{|| aItens[oBrwCW0:nAt,2]},,,,"LEFT",150,.F.,.F.,,,,,))
				oBrwCW0:Align     := CONTROL_ALIGN_ALLCLIENT
				oBrwCW0:lAutoEdit := .F.
				oBrwCW0:lReadOnly := .F.
				oBrwCW0:SetArray(aItens)
				oDlgCW0:lCentered := .T.
			oDlgCW0:Activate(,,,,)
		Else
			Help(" ",1,"CT5PLGER1",,STR0031+" "+cTabela,1,0)//"No foram encontrados itens para a tabela "
		Endif
	Else
		Help(" ",1,"CT5PLGER2",,STR0032 +" " + cTabela +" " + STR0033,1,0)//"Tabela "##" no encontrada na lista de tabelas auxiliares"
	Endif
	RestArea(aArea)
	If nItem > 0
		CW0->(DbGoTo(aItens[nItem,3]))
		xRet := .T. //aItens[nItem,1]
	Endif
Return(xRet)
/*


ͻ
Programa  DecodSoma1Autor  Microsiga            Data   16/07/10   
͹
Desc.     Decodifica Soma1() com parametro MV_SOMAOLD = .F.           
                                                                      
͹
Uso        AP                                                         
ͼ


*/

Function DecodSoma1(cCodigo)
Local nTam := Len(cCodigo)
Local nX
Local nStep
Local cMaxCod
Local nDecCod := 0
Local cCodB10
Local cCodB36
Local nB36Cod

If _lSomaOld == NIL
	_lSomaOld := GetMv("MV_SOMAOLD",,.F.)
EndIf

If nTam >= 1

	cMaxCod := Repl("9", nTam)

	If cCodigo <= cMaxCod
		nDecCod := Val(cCodigo)
	Else

		If _lSomaOld

			nDecCod := DecSoma1Old(cCodigo)   //somente com ate 6 digitos

		Else

			nStep := 0
			FOR nX := nTam TO 1 STEP -1

				nStep++
				cMaxCod := Repl("9", nX - 1)+Repl("Z", nStep)

				If cCodigo <= cMaxCod

					cCodB10 := Left(cCodigo, nX - 1)
					cCodB36 := Right(cCodigo, nStep)

					nDecCod := Val(cCodB10) * (10 ^ nStep)

					nB36Cod := DecoBase36(cCodB36)

					nDecCod += nB36Cod - S1AjustB36(Len(cCodB36))
					Exit

				EndIf

		    Next //nX

	    EndIf

	EndIf

EndIf

Return(nDecCod)


/*


ͻ
Programa  DecoBase36Autor  Microsiga            Data   16/07/10   
͹
Desc.     Usado para decodificar Soma1() com parametro                
          MV_SOMAOLD = .F.  --> decodifica em base 36                 
͹
Uso        AP                                                         
ͼ


*/

Function DecoBase36(cCodB36)
Local nRet := 0
Local nTam
Local nX
Local cBase36 := "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"

nTam := Len(cCodB36)

nExpoente := 0

FOR nX := nTam TO 1 STEP -1

	cString := Substr(cCodB36, nX, 1)

	nPosStr := At(cString, cBase36)

	nRet += nPosStr*(36^nExpoente)

	nExpoente++

NEXT

Return(nRet)

/*


ͻ
Programa  S1AjustB36Autor  Microsiga            Data   16/07/10   
͹
Desc.     Usado para decodificar Soma1() com parametro                
          MV_SOMAOLD = .F.  --> decodifica em base 36                 
          Fator de Ajuste para decodificar                            
͹
Uso        AP                                                         
ͼ


*/

Function S1AjustB36(nTam)
Local nRet := 0

If nTam == 1
	nRet := DecoBase36("A")-(10^nTam)
Else
	nRet := DecoBase36(Repl("9",nTam-1)+"A")-(10^nTam)
EndIf

Return(nRet)

/*


ͻ
Programa  DecSoma1Old Autor Microsiga           Data   16/07/10   
͹
Desc.     Usado para decodificar Soma1() com parametro                
          MV_SOMAOLD = .T. (antiga forma soma1  --> decodifica em     
          base 36 com ajuste                                          
͹
Uso        AP                                                         
ͼ


*/

Function DecSoma1Old(cCodigo)
Local nTam 		:= Len(cCodigo)
Local nRet  	:= 0
Local aTipos   := {}
Local aDifer   := {}
Local nX
Local cDigito
Local nPosNumero
Local nDigB36
Local nFator

If cCodigo <= Repl("9", nTam)
	nRet := Val(cCodigo)
Else
	If nTam == 1
		nRet := DecoBase36(cCodigo)-1
	Else
		For nX := 1	 To nTam
			cDigito := Substr(cCodigo, nX, 1)
			nDigB36 := DecoBase36(cDigito)
			If nDigB36 > 10
				aAdd(aTipos, "C") //caracter
				aAdd(aDifer, DecoBase36(cDigito)-DecoBase36("A") )
			Else
				aAdd(aTipos, "N") //numeros
				aAdd(aDifer, Val(cDigito) )
			EndIf
		Next

		nPosNumero := Ascan(aTipos, "N")

		If nPosNumero == 0 //soh tem letras
			nFator := 0
			For nX := 1 TO nTam - 1
				nFator += Soma1Fator((nTam-nX)+1, aDifer[nX])
			Next
			nFator += DecoBase36(Right(cCodigo,1))
			nRet := nFator
			nRet--
		Else
			nFator := 0
			For nX := 1 TO nPosNumero-1
				nFator += Soma1Fator((nTam-nX)+1, aDifer[nX])
			Next
			nFator += Val(Substr(cCodigo,nPosNumero))
			nRet := nFator
	    EndIf
	EndIf

EndIf

Return(nRet)

/*


ͻ
Programa  Soma1Fator  Autor Microsiga           Data   16/07/10   
͹
Desc.     Usado para decodificar Soma1() com parametro                
          MV_SOMAOLD = .T. (antiga forma soma1  --> decodifica em     
          base 36 com ajuste                                          
          obs: codigos somente com ate 6 digitos                      
͹
Uso        AP                                                         
ͼ


*/

Function Soma1Fator(nTam, nElem)
Local nRet := 0
Local nDecAux := 0

If nTam > 1  //somente utilizado para tamanho 2 em diante

	nRet += nElem * (26^(nTam-2))
	nRet *= 36

	//parte decimal
	nDecAux := (10^(nTam))   //parte fixa

	If 		nTam-1 == 1
			nDecAux += 0
	ElseIf 	nTam-1 == 2
			nDecAux += nElem*100     		// 10 x 10
	ElseIf nTam-1 == 3
			nDecAux += nElem*3600    		// 36*10 * 10
	ElseIf nTam-1 == 4
			nDecAux += nElem*103600  		//
	ElseIf nTam-1 == 5
			nDecAux += nElem*18003600      	//
	EndIf

	nRet += nDecAux

EndIf

Return( nRet)

/*


ͻ
Programa  CTBXFUNA  Autor  Microsiga            Data   02/02/15   
͹
Desc.      Wizard                                                     
                                                                      
͹
Uso        AP                                                        
ͼ


*/

Function CtbWizard(aWizMain, aWizPanel, aPanel, lCenter, bValid, bInit, bWhen)
Local oWizard
Local nX
Local cTitle
Local cMsgWelcome
Local bNext
Local bBack
Local lPanel
Local lNoFirst
Local bFinish
Local bExecute

Default aWizMain 	:= {}
Default aWizPanel 	:= {}
Default aPanel 		:= {}
Default lCenter 	:= .T.
Default bValid 		:= {||.T.}
Default bInit 		:= {||.T.}
DeFault bWhen 		:= {||.T.}

If Len(aWizMain) > 0
	//Ŀ
	// Array aWizMain - Estrutura:                         
	// Posicao 1 - Titulo                                  
	//         2 - Mensagem Explicativa                    
	//         3 - bNext                                   
	//         4 - bFinish                                 
	//         5 - lPanel                                  
	//         6 - lNoFist                                 
	//


	//Ŀ
	// Painel 1 - Tela inicial do Wizard 		            
	//
	cTitle 		:= If(Len(aWizMain) > 0 .And. aWizMain[1]==NIL, ""		,aWizMain[1])
	cMessage 	:= If(Len(aWizMain) > 1 .And. aWizMain[2]==NIL, ""		,aWizMain[2])
	bNext 		:= If(Len(aWizMain) > 2 .And. aWizMain[3]==NIL, {||.T.}	,aWizMain[3])
	bFinish 	:= If(Len(aWizMain) > 3 .And. aWizMain[4]==NIL, {||.T.}	,aWizMain[4])
	lPanel 		:= If(Len(aWizMain) > 4 .And. aWizMain[5]==NIL, .T.		,aWizMain[5])
	lNoFirst 	:= If(Len(aWizMain) > 5 .And. aWizMain[6]==NIL, .F.		,aWizMain[6])

	oWizard := APWizard():New( cTitle/*<chTitle>*/,;
								""/*<chMsg>*/,;
								""/*<cTitle>*/, ;
								cMessage, ;
								bNext,;
								bFinish,;
								lPanel,;
								,;
								,;
								lNoFirst)

	//Ŀ
	// Paineis                                             
	// Array aWizPanel - Estrutura:
	// Para cada linha dete array multidimensional         
	// Posicao 1 - Titulo do painel                        
	//         2 - Mensagem Explicativa                    
	//         3 - bNext                                   
	//         4 - bFinish                                 
	//         5 - lPanel                                  
	//         6 - bBack                                   
	//         7 - bExecute                                
	//
	For nX := 1 To Len(aWizPanel)
		cTitle 		:= If(Len(aWizPanel[nx]) > 0 .And. aWizPanel[nx][1]==NIL, ""		,aWizPanel[nx][1])
		cMessage 	:= If(Len(aWizPanel[nx]) > 1 .And. aWizPanel[nx][2]==NIL, ""		,aWizPanel[nx][2])
		bNext 		:= If(Len(aWizPanel[nx]) > 2 .And. aWizPanel[nx][3]==NIL, {||.T.},aWizPanel[nx][3])
		bFinish 	:= If(Len(aWizPanel[nx]) > 3 .And. aWizPanel[nx][4]==NIL, {||.T.},aWizPanel[nx][4])
		lPanel 		:= If(Len(aWizPanel[nx]) > 4 .And. aWizPanel[nx][5]==NIL, .T.	,aWizPanel[nx][5])
		bBack	 	:= If(Len(aWizPanel[nx]) > 6 .And. aWizPanel[nx][6]==NIL, {||.T.},aWizPanel[nx][6])
		bExecute 	:= If(Len(aWizPanel[nx]) > 7 .And. aWizPanel[nx][7]==NIL, {||.T.},aWizPanel[nx][7])

		oWizard:NewPanel(	cTitle/*<chTitle>*/,;
							cMessage/*<chMsg>*/,;
							bBack,;
							bNext,;
							bFinish,;
							lPanel,;
							bExecute)

		aAdd(aPanel, oWizard:oMPanel[nX+1] )

	Next

	oWizard:Activate( 	lCenter,;
						bValid,;
						bInit,;
						bWhen)
EndIf

Return

/*


ͻ
Programa  CtbQtdEntdAutor  Paulo Carnelossi     Data   21/06/10   
͹
Desc.      Retorna quantidade de entidades cadastradas na tabela CT0  
                                                                      
͹
Uso        AP                                                         
ͼ


*/
Function CtbQtdEntd()
Local nQtdEntid := 4
Local aArea 	:= GetArea()
Local aAreaCT0  := CT0->(GetArea())
Local cAliasEnt	:= "CT0"

If Type("lCTB240Ori")=='L'
	If lCTB240Ori
		cAliasEnt := "CTBCT0"
	EndIf
EndIf

nQtdEntid := 0
dbSelectArea(cAliasEnt)
dbSetOrder(1)

dbSeek(xFilial("CT0"))

While (cAliasEnt)->(! Eof() .And. CT0_FILIAL == xFilial("CT0") )
	nQtdEntid++
	(cAliasEnt)->(dbSkip())
EndDo

If nQtdEntid<4 // Caso a CT0 exista, mas no existam pelo menos as 4 entidades, carrega as configuracoes do CTB
	CTBLoad() // Carrega configuracoes do mdulo CTB

	nQtdEntid := 0
	dbSelectArea(cAliasEnt)
	dbSetOrder(1)

	dbSeek(xFilial("CT0"))

	Do While (cAliasEnt)->(! Eof() .And. CT0_FILIAL == xFilial("CT0") )
		nQtdEntid++
		(cAliasEnt)->(dbSkip())
	EndDo
EndIf

If nQtdEntid<4 // Se ainda nao existem pelo menos as 4 entidades, retorna 4
	nQtdEntid := 4
EndIf

RestArea(aAreaCT0)
RestArea(aArea)

Return(nQtdEntid)

/*


ͻ
Programa  CtbUseAmarAutor  Paulo Carnelossi     Data   21/06/10   
͹
Desc.      Retorna parametrizacao referente amarracao de entidades    
           0 - nao tem amarracao                                      
           1 - Regra de nveis                                        
           2 - Regra de Amarrao tabela CTA                          
͹
Uso        AP                                                         
ͼ


*/
Function CtbUseAmar()
Local cAmarracao := SuperGetMv('MV_CTBAMAR',.F.,"0")
Return(cAmarracao)

/*


ͻ
Programa  CtbIsCube Autor  Paulo Carnelossi     Data   21/06/10   
͹
Desc.      Retorna se trabalha com cubos gerenciais utilizando a      
           tabela CT0 como cadastro de cubos sendo que a estrutura    
           do cubo sera todos os registros ate o ID do cubo           
           Parametro MV_CTBCUB   (CARACTER)                           
           0 - Nao trabalha com cubo                                  
           1 - Trabalha com Cubo                                      
͹
Uso        AP                                                         
ͼ


*/
Function CtbIsCube()
Local lRet := .F.
Local aArea := GetArea()

lRet := SuperGetMv('MV_CTBCUBE',.F.,"0")=="1"

If lRet  //se trabalha com os cubos deve provocar abertura dos alias CVX/CVY/CVZ
	dbSelectArea("CVX")
	dbSelectArea("CVY")
	dbSelectArea("CVZ")
Endif

RestArea(aArea)

Return(lRet)


/*


ͻ
Programa  CtbEntArrAutor  Alvaro Camillo Neto  Data   04/11/12   
͹
Desc.      Retorna um array com os ID das novas entidades contbeis   
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtbEntArr(lTodasEnt)
Local aRet     := {}
Local aArea    := GetArea()
Local aAreaCT0 := {}

Default lTodasEnt := .F.

If AliasInDic("CT0")
	aAreaCT0 := CT0->(GetArea())
	CT0->(dbSetOrder(1)) //CT0_FILIAL+CT0_ID
	If CT0->(MsSeek(xFilial("CT0")))
		While CT0->(!EOF()) .And. CT0->CT0_FILIAL == xFilial("CT0")
			If lTodasEnt
				aAdd(aRet,CT0->CT0_ID )
			Else
				If CT0->CT0_ID > "04"
					aAdd(aRet,CT0->CT0_ID )
				EndIf
			EndIf

			CT0->(dbSkip())
		EndDo
	EndIf
	RestArea(aAreaCT0)
EndIf

RestArea(aArea)
Return aRet
/*


ͻ
Programa  CtbVerSX2 Autor  Paulo Carnelossi     Data   21/06/10   
͹
Desc.      CtbVerSX2(cAlias, lHelp) - Retorna .T. se existe a tabela  
           especificada no alias no dicionario SX2, ou .F. se nao     
͹
Uso        AP                                                         
ͼ


*/
Function CtbVerSX2()

//---------------------------------------------------------------------
// As rotinas que utilizam essa funcao avaliam somente a CT0 nao sendo
// mais necessaria essa avaliacao devido o release incremental
//---------------------------------------------------------------------

Return(.T.)

/*


ͻ
Programa  CTBVldNEntAutor  Totvs               Fecha  03/12/2010  
͹
Desc.     Valida as novas entidades contabeis.                        
ͼ


*/
Function CTBVldNEnt( lHelp, cEnt5, cEnt6, cEnt7, cEnt8, cEnt9, cEntidade,cDc )
Local lRet := .T.
Default cDc := ""

If lRet .AND. CT1->( FieldPos( "CT1_05OBRG" ) ) > 0
	If CT1->CT1_05OBRG == "1" .And. Empty(cEnt5)
		cEntidade := cEntidade + Iif(!Empty(cEntidade),CRLF,"") + "05 " + cDc
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
EndIf

If lRet .AND. CT1->( FieldPos( "CT1_06OBRG" ) ) > 0
	If CT1->CT1_06OBRG == "1" .And. Empty(cEnt6)
		cEntidade := cEntidade + Iif(!Empty(cEntidade),CRLF,"") + "06 " +  cDc
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
EndIf

If lRet .AND. CT1->( FieldPos( "CT1_07OBRG" ) ) > 0
	If CT1->CT1_07OBRG == "1" .And. Empty(cEnt7)
		cEntidade := cEntidade + Iif(!Empty(cEntidade),CRLF,"") + "07 " +  cDc
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
EndIf

If lRet .AND. CT1->( FieldPos( "CT1_08OBRG" ) ) > 0
	If CT1->CT1_08OBRG == "1" .And. Empty(cEnt8)
		cEntidade := cEntidade + Iif(!Empty(cEntidade),CRLF,"") + "08 " +  cDc
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
EndIf

If lRet .AND. CT1->( FieldPos( "CT1_09OBRG" ) ) > 0
	If CT1->CT1_09OBRG == "1" .And. Empty(cEnt9)
		cEntidade := cEntidade + Iif(!Empty(cEntidade),CRLF,"") + "09 " +  cDc
		If lHelp
			Help(" ",1,"ENTIDOBRIG",,cEntidade,3,1)
		EndIf
		lRet := .F.
	EndIf
EndIf

Return lRet

/*


Ŀ
Funo	 TamSXG  Autor  Alvaro Camillo Neto  	 Data  14/01/10 
Ĵ
Descrio  Funo que retorna tamanho do campo                        
Ĵ
 Uso       Geral                                                      
ٱ


*/
Function CtbTamSXG(cGrupo,nTamPad)
Local nSize := 0

DbSelectArea("SXG")
DbSetOrder(1)

IF DbSeek(cGrupo)
	nSize := SXG->XG_SIZE
Else
	nSize := nTamPad
Endif

Return nSize

/*


ͻ
Programa  CtUpdLPCW0Autor  Totvs               Fecha  03/12/2010  
͹
Desc.     Atualiza o CW0 LP indicando se eh zeram. c/cta ponte ou nao.   
ͼ


*/
Function CtUpdLPCW0()
Local aSaveArea	:= GetArea()

Local cQuery	:= ""
Local cChar		:= ""
Local cAliasTRB := GetNextAlias()

Local dDataLP	:= CTOD("  /  /  ")

Local cLote		:= ""
Local cSubLote	:= ""
Local cDoc		:= ""
Local cTpSald	:= ""
Local cEmpOri	:= ""
Local cFilOri	:= ""
Local cMoeda	:= ""
Local lProcessado := .F.
Local cCampo :=  "CW0->CW0_DESC01"
Local aLstCW0 := {}

If CtLPCW0Tab()
	dbSelectArea("CW0")
	dbSelectArea("CTZ")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
	CTZ->(dbSetOrder(1)) //CTZ_FILIAL+CTZ_DATA+CTZ_LOTE+CTZ_SBLOTE+CTZ_DOC+CTZ_TPSALD+CTZ_EMPORI+CTZ_FILORI+CTZ_MOEDLC+CTZ_LINHA+CTZ_SEQLIN

	If CW0->(MsSeek(xFilial("CW0")+"LP"))
		cChar	:= Subs(&(cCampo),12,1)
		If cChar $ "P/Z"
			Return
		EndIf
	EndIf

	//DATAS DE APURACAO COM CONTA PONTE
	cQuery := "SELECT DISTINCT CT2_FILIAL, CT2_DTLP, CT2_LOTE, CT2_SBLOTE, CT2_DOC, CT2_TPSALD, "
	cQuery += " CT2_EMPORI, CT2_FILORI, CT2_MOEDLC "
	cQuery += " FROM "+RetSqlName("CT2")
	cQuery += " WHERE D_E_L_E_T_ = ' ' "
	cQuery += " AND CT2_FILIAL = '"+xFilial("CT2")+"' "
	cQuery += " AND CT2_DTLP <> ' ' "
	cQuery += " ORDER BY CT2_FILIAL, CT2_DTLP, CT2_LOTE, CT2_SBLOTE, CT2_DOC, CT2_TPSALD, CT2_EMPORI, CT2_FILORI, CT2_MOEDLC "
	cQuery := ChangeQuery(cQuery)

	dbUseArea(.T.,"TOPCONN",TcGenQry(,,cQuery),cAliasTRB,.T.,.F.)

	TCSetField(cAliasTRB,"CT2_DTLP", "D",8,0)

	dbSelectArea(cAliasTRB)
	While (cAliasTRB)->(!Eof())
		dDataLp	:= (cAliasTRB)->CT2_DTLP
		cLote	:= (cAliasTRB)->CT2_LOTE
		cSubLote:= (cAliasTRB)->CT2_SBLOTE
		cDoc	:= (cAliasTRB)->CT2_DOC
		cTpSald	:= (cAliasTRB)->CT2_TPSALD
		cEmpOri	:= (cAliasTRB)->CT2_EMPORI
		cFilOri	:= (cAliasTRB)->CT2_FILORI
		cMoeda	:= (cAliasTRB)->CT2_MOEDLC

		If CTZ->(MsSeek(xFilial()+DTOS(dDataLP)+cLote+cSubLote+cDoc+cTpSald+cEmpOri+cFilOri+cMoeda))
			cChar	:= "P"	//Indica que eh apuracao com conta ponte
		Else
			cChar	:= "Z"	//Indica que eh apuracao com zeramento de receita/despesa
		EndIf

		//Armazena no array todas os registros da empresa / filial que esta sendo apurada - - protecao para nao causar error log chv unica
		aLstCW0 := {}
		If CW0->(MsSeek(xFilial("CW0")+"LP"+cEmpAnt+cFilAnt))	//FILIAL+TABELA+CHAVE
			While CW0->(!Eof()) .And. CW0->CW0_FILIAL == xFilial("CW0") .And.  AllTrim(CW0->CW0_TABELA) == "LP" .And. Subs(CW0->CW0_CHAVE,1,2) == cEmpAnt ;
				.And. Alltrim(Subs(CW0->CW0_CHAVE,3,Len(CW0->CW0_CHAVE))) == Alltrim(cFilAnt)
				aAdd(aLstCW0, { CW0->CW0_FILIAL, CW0->CW0_TABELA, CW0->CW0_CHAVE, CW0->CW0_DESC01 } )
				CW0->(dbSkip())
			End
		EndIf

		BEGIN TRANSACTION
		If CW0->(MsSeek(xFilial("CW0")+"LP"+cEmpAnt+cFilAnt))	//FILIAL+TABELA+CHAVE
			While CW0->(!Eof()) .And. CW0->CW0_FILIAL == xFilial("CW0") .And.  AllTrim(CW0->CW0_TABELA) == "LP" .And. Subs(CW0->CW0_CHAVE,1,2) == cEmpAnt ;
				.And. Alltrim(Subs(CW0->CW0_CHAVE,3,Len(CW0->CW0_CHAVE))) == Alltrim(cFilAnt)
				If Subs(&(cCampo),1,8) == DTOS(dDataLP) .And. Subs(&(cCampo),9,2) == cMoeda .And. ;
					Subs(&(cCampo),11,1) == cTpSald
					If Subs(&(cCampo),12,1) == " "
						RecLock("CW0",.F.)
						&(cCampo)	:= DTOS(dDataLP)+cMoeda+cTpSald+cChar
						MsUnlock()
					ElseIf Subs(&(cCampo),12,1) <> "" .And. Subs(&(cCampo),12,1) <> cChar
						//somente appenda o registro se nao encontrado na tabela CW0 - protecao para nao causar error log chv unica
						If aScan(aLstCW0,{|x| x[1]==xFilial("CW0") .And. x[2] == "LP" .And. x[3] == PadR(cEmpAnt+cFilAnt,Len(CW0->CW0_CHAVE)) .And. Alltrim(x[4]) == DTOS(dDataLP)+cMoeda+cTpSald+cChar } ) == 0
							RecLock("CW0",.T.)
							CW0->CW0_FILIAL 	:= xFilial("CW0")
							CW0->CW0_TABELA	:= 'LP'
							CW0->CW0_CHAVE	:= cEmpAnt+cFilAnt
							&(cCampo)		:= DTOS(dDataLP)+cMoeda+cTpSald+cChar
							MsUnlock()
						EndIf
					EndIf
				Endif
				CW0->(dbSkip())
			End
		EndIf
		END TRANSACTION
	(cAliasTRB)->(dbSkip())
	End
	(cAliasTRB)->(dbCloseArea())

EndIf

Restarea(aSaveArea)

Return lProcessado


/*


ͻ
Programa  CtLPCW0VdtAutor  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.      Valida a data de apurao de resultado                     
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtLPCW0Vdt(dDataLP,lJaExec,lPergOk,cMoeda,cTpSaldo,lMoedaEsp,lAlertMsg)
Local cCampo :=  "CW0->CW0_DESC01"
Local lOk	 := .T.
Local aArea  := GetArea()

Default dDataLP 	:= cToD("")
Default lJaExec		:= .T.
Default lPergOk		:= .T.
Default cMoeda		:= ""
Default cTpSaldo	:= ""
Default lMoedaEsp	:= .T.
Default lAlertMsg 	:= .T.

//Ŀ
// ANTES DE INICIAR O PROCESSAMENTO, VERIFICO OS PARAMETROS.	 
//
//Data de Apuracao nao preenchida.
If CtLPCW0Tab()
	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE

	If Empty(dDataLP)
		Help(" ",1,"NOCTBDTLP")

		//Ŀ
		// Atualiza o log de processamento com o erro  
		//
		ProcLogAtu("ERRO","NOCTBDTLP",Ap5GetHelp("NOCTBDTLP"))

		lOk := .F.
	Else //Se a data estiver preenchida, verifica se ja foi rodado nessa data.
		If lAlertMsg
			If CW0->(MsSeek(xFilial("CW0")+"LP"+cEmpAnt+cFilAnt))
				While CW0->(!Eof()) .and. CW0->CW0_TABELA == "LP" .And. CW0->CW0_FILIAL == xFilial("CW0")
					If Subs(&(cCampo),1,8) == Dtos(dDataLP)
						If (!lMoedaEsp .Or. (lMoedaEsp .And. Subs(&(cCampo),9,2) == cMoeda)) .And.;
								Subs(&(cCampo),11,1) == cTpSaldo
							If ! MsgYesNo(STR0002,OemToAnsi(STR0035))//"Rotina ja executada nessa data. Executa novamente ?"##"ATENCAO"
								lOk := .F.
							Else
								lJaExec := .T.
								Exit
							Endif
						EndIf
					Endif
					CW0->(dbSkip())
				End
			EndIf
		EndIf
		//Verificar se o calendario da data solicitada esta encerrado
		lPergOk	:= CtbValiDt(1,dDataLP,,cTpSaldo)
	Endif
Else
	lRet := .F.
EndIf

RestArea(aArea)
Return lOk


/*


ͻ
Programa  CtAtLPCW0 Autor  Microsiga            Data   11/30/10   
͹
Desc.     Atualizo a tabela LP da CW0                                 
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtAtLPCW0(dDataLP,lMoedaEsp,cMoeda,nInicio,nFinal,cTpSaldo,lPontes)
Local aSaveArea	:= GetArea()
Local cChave	:= cEmpAnt+cFilant
Local lExiste	:= .F.
Local nContad
Local cChar		:= ""
Local cCampo	:= "CW0->CW0_DESC01"
Local aLstCW0   := {}

If CtLPCW0Tab()

	If lPontes
		cChar	:= "P"
	Else
		cChar	:= "Z"
	EndIf

	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
	If CW0->(MsSeek(xFilial("CW0")+'LP'+cChave))
		//Armazena no array todas os registros da empresa / filial que esta sendo apurada - - protecao para nao causar error log chv unica
		aLstCW0 := {}
		If CW0->(MsSeek(xFilial("CW0")+"LP"+cEmpAnt+cFilAnt))	//FILIAL+TABELA+CHAVE
			While CW0->(!Eof()) .And. CW0->CW0_FILIAL == xFilial("CW0") .And.  AllTrim(CW0->CW0_TABELA) == "LP" .And. Subs(CW0->CW0_CHAVE,1,2) == cEmpAnt ;
				.And. Alltrim(Subs(CW0->CW0_CHAVE,3,Len(CW0->CW0_CHAVE))) == Alltrim(cFilAnt)
				aAdd(aLstCW0, { CW0->CW0_FILIAL, CW0->CW0_TABELA, CW0->CW0_CHAVE, CW0->CW0_DESC01 } )
				CW0->(dbSkip())
			End
		EndIf
	EndIf

	For nContad	:= nInicio to nFinal

		If CW0->(!MsSeek(xFilial("CW0")+'LP'+cChave))
			Reclock("CW0",.T.)
			CW0->CW0_FILIAL := xFilial("CW0")
			CW0->CW0_TABELA	:= 'LP'
			CW0->CW0_CHAVE	:= cChave
			&(cCampo)		:= Dtos(dDataLP)+StrZero(nContad,2)+cTpSaldo+cChar
			MsUnlock()
		Else
			While CW0->(!Eof()) .And. CW0->CW0_FILIAL == xFilial("CW0") .And. CW0->CW0_TABELA = 'LP' .And. ;
				Alltrim(Subs(CW0->CW0_CHAVE,1,Len(CW0->CW0_CHAVE))) == Alltrim(cChave)

		  	  	If Empty(StoD(CW0->CW0_DESC01,1,8))
					Reclock("CW0")
					CW0->(dbDelete())
					MsUnlock()
					CW0->(dbSkip())
				Endif

				If Subs(&(cCampo),1,8) == Dtos(dDataLP)
					If lMoedaEsp .And. (Subs(&(cCampo),9,2) == cMoeda) .And. Subs(&(cCampo),11,1) = cTpSaldo .And. Subs(&(cCampo),12,1) == cChar
						lExiste	:= .T.
					ElseIf !lMoedaEsp .And. (Subs(&(cCampo),9,2) == StrZero(nContad,2)).And. Subs(&(cCampo),11,1) = cTpSaldo  .And. Subs(&(cCampo),12,1) == cChar
						lExiste	:= .T.
					EndIf
				EndIf

				If !lExiste
					//somente appenda o registro se nao encontrado na tabela CW0 - protecao para nao causar error log chv unica
					If aScan(aLstCW0,{|x| x[1]==xFilial("CW0") .And. x[2] == "LP" .And. x[3] == PadR(cChave,Len(CW0->CW0_CHAVE)) .And. Alltrim(x[4]) == If(lMoedaEsp,Dtos(dDataLP)+cMoeda+cTpSaldo+cChar,Dtos(dDataLP)+StrZero(nContad,2)+cTpSaldo+cChar) } ) == 0
						Reclock("CW0",.T.)
						CW0->CW0_FILIAL := xFilial("CW0")
						CW0->CW0_TABELA	:= 'LP'
						CW0->CW0_CHAVE	:= cChave
						If lMoedaEsp
							&(cCampo)	:= Dtos(dDataLP)+cMoeda+cTpSaldo+cChar
						Else
							&(cCampo)	:= Dtos(dDataLP)+StrZero(nContad,2)+cTpSaldo+cChar
						EndIf
						MsUnlock()
					EndIf
				EndIf
				CW0->(dbSkip())
			End
		EndIf
	Next
EndIf

RestArea(aSaveArea)
Return


/*


ͻ
Programa  CtMaxLPCW0  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.     Retorna qual eh a ultima data de zeramento SEM conta ponte. 
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtMaxLPCW0()
Local aSaveArea	:= GetArea()
Local dMaxData	:= CTOD("  /  /  ")
Local cCampo	:= "CW0->CW0_DESC01"

If CtLPCW0Tab()
	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
	If CW0->(MsSeek(xFilial("CW0")+"LP"+cEmpAnt+cFilAnt,.F.))
		While CW0->(!Eof()) .And. CW0->CW0_FILIAL == xFilial() .And. Subs(CW0->CW0_CHAVE,1,2) == cEmpAnt .And. ;
			Alltrim(Subs(CW0->CW0_CHAVE,3,Len(CW0->CW0_CHAVE))) == Alltrim(cFilAnt)

			If Subs(&(cCampo),12,1) == "Z"
				dMaxData	:= STOD(Subs(&(cCampo),1,8))
			EndIf

			dbSkip()
		End
	EndIf
	RestArea(aSaveArea)
EndIf

Return(dMaxData)

/*


ͻ
Programa  CtMosLPCW0  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.      Valida se a tabela existe e mostra a consulta da tabela    
           CTZ                                                        
͹
Uso        AP                                                        
ͼ


*/
Function CtMosLPCW0()
Local a
Local b
Local c
Local aAreaOri := GetArea()
Local aAreaCW0  := CW0->(GetArea())

// Caso a tabela LP exista na tabela CW0 o processo ser feito por ela e nao pela SX5
If CtLPCW0Tab()
	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
	If CW0->(!MsSeek(xFilial("SX5")+"LP",.F.))
		MsgInfo("No existem apuraes registradas.","Tabela LP - Apuraes de resultado")//"No existem apuraes registradas."//"Tabela LP - Apuraes de resultado"
	Else
		ConPad1(a,b,c,"CTZ",,,.F.)
	EndIf
EndIf

RestArea(aAreaCW0)
RestArea(aAreaOri)

Return


/*


ͻ
Programa  CtExcLPCW0  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.      Atualizo a tabela LP do CW0                                  
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtExcLPCW0(dDataLP,lMoedaEsp,cMoeda,nInicio,nFinal,cTpSald)
Local aSaveArea := GetArea()
Local cChave    := cEmpAnt + cFilant
Local cFilProc  := ""

If CtLPCW0Tab()
	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE

	If CW0->(MsSeek(xFilial("CW0")+'LP'+cChave))
   		cFilProc	:= Subs(CW0->CW0_CHAVE,3,Len(CW0->CW0_CHAVE))

		While CW0->(!Eof()) .And.	CW0->CW0_FILIAL == xFilial("CW0") .And.;
			Subs(CW0->CW0_TABELA,1,2) == "LP" .And.  ;
			Subs(CW0->CW0_CHAVE,1,2) == cEmpAnt .And. ;
			AllTrim(xFilial("CT2",cFilProc)) == AllTrim(xFilial("CT2",cFilAnt)) .And. ;
			AllTrim( Subs(CW0->CW0_CHAVE,3,Len(CW0->CW0_CHAVE)) ) == AllTrim( cFilAnt )

			If Subs(CW0->CW0_DESC01,1,8) <> Dtos(dDataLP)
				CW0->(dbSkip())
				Loop
			Endif

			If Subs(CW0->CW0_DESC01,11,1) <> cTpSald
				CW0->(dbSkip())
				Loop
			EndIf

			If 	(lMoedaEsp .And. (Subs(CW0->CW0_DESC01,9,2) <> StrZero(nInicio,2))) .Or. ;
				(!lMoedaEsp .And. (Subs(CW0->CW0_DESC01,9,2) < StrZero(nInicio,2) .Or. ;
				Subs(CW0->CW0_DESC01,9,2) > StrZero(nFinal,2)))
				CW0->(dbSkip())
				Loop
			EndIf

			Reclock("CW0",.F.,.T.)
			CW0->( dbDelete() )
			CW0->( MsUnlock() )
			CW0->(dbSkip())
		EndDo
	EndIf
EndIf

RestArea(aSaveArea)
Return Nil

/*/

Ŀ
Funo    CtDtExcLPCW0Autor  Alvaro Camillo Neto  Data   30/11/10   
Ĵ
Descrio Verifica se a data solicitada eh ref. o ult. zeramento      
Ĵ
Sintaxe   				                                              
Ĵ
 Uso                                                                  
ٱ


/*/
Function CtDtExcLPCW0(dDataLp,cTpSald,lMoedaEsp,cMoeda)

Local aSaveArea	:= GetArea()
Local lRet		:= .T.
Local cDataLP	:= DTOS(dDataLp)
Local lSaiW		:= .F.
Local cEmpFil	:= cEmpAnt+cFilAnt
Local cFilCW0	:= ""

If CtLPCW0Tab()
	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
	cFilCW0	:= xFilial("CW0")

	CW0->(dbSeek(xFilial("CW0")+"LP"+cEmpAnt+Soma1(cFilAnt),.T.))
	CW0->(dbSkip(-1))
	While !lSaiW .AND. CW0->CW0_FILIAL == cFilCW0 .and. ALLTRIM(CW0->CW0_TABELA) == "LP" .and. ALLTRIM(CW0->CW0_CHAVE) == ALLTRIM(cEmpFil)
		If cTpSald == SubStr(CW0->CW0_DESC01,11,1)	/// TIPO DE SALDO DEVE SER VERIFICADO INDEPENDENTE DA MOEDA
			lMoedaChk := .T.
			/// SE FOR APURACAO DE MOEDA ESPECIFICA
			If lMoedaEsp .and. cMoeda <> SubStr(CW0->CW0_DESC01,9,2)
				lMoedaChk := .F.
			Endif
			If lMoedaChk	/// SE FOR A MESMA MOEDA / OU PROCESSAMENTO DE TODAS AS MOEDAS
				lSaiW := .T.
				Exit		/// FORA SAIDA PRA NAO DESPOSICIONAR O CW0 (VAI PEGAR A DATA)
			EndIf
		EndIf
		CW0->(dbSkip(-1))
	EndDo

	If lSaiW .AND. CW0->CW0_FILIAL == cFilCW0 .and. ALLTRIM(CW0->CW0_TABELA) == "LP" .and. ALLTRIM(CW0->CW0_CHAVE) == ALLTRIM(cEmpFil)
		If cDataLP < Substr(CW0->CW0_DESC01,1,8)
			/// SE NO FOR A LTIMA DATA DE APURAO NA EMPRESA E FILIAL
			lRet	:= .F.
			MsgInfo("Verifique se a data solicitada refere-se ao ultimo zeramento efetuado...","Data: "+DTOC(dDataLP)+" Moeda: "+If(lMoedaEsp,cMoeda,SUBSTR(CW0->CW0_DESC01,9,2))+" Tp.Saldo: "+cTPSald)
		EndIf
	EndIf


EndIf

RestArea(aSaveArea)/// ATENO ! MANTER SX5 POSICIONADO NO RETORNO Ct215LPAnt( OBTEM DATA ANTERIOR E IRA DESPOSICIONAR )
Return(lRet)

/*


ͻ
Programa  CtLPAntCW0Autor  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.      Retorna a ultima data de apurao de resultado antes da    
           indicada                                                   
͹
Uso        AP                                                        
ͼ


*/
Function CtLPAntCW0(dDataLp,cTpSald,lMoedaEsp,cMoeda)
Local dDTLPAnt := CTOD('  /  /  ')
Local cEmpFil	:= cEmpAnt+cFilAnt
Local cDataLP  := DTOS(dDataLp)
Local cFilCW0  := ""
Local lMoedaChk:= .T.

If CtLPCW0Tab()
	dbSelectArea("CW0")
	cFilCW0 := xFilial("CW0")

	If !Eof() .AND. CW0->CW0_FILIAL == cFilCW0 .and. ALLTRIM(CW0->CW0_TABELA) == "LP" .and.;
		ALLTRIM(CW0->CW0_CHAVE) == ALLTRIM(cEmpFil) .and. cDataLP == Substr(CW0->CW0_DESC01,1,8)
		/// SE JA ESTIVER POSICIONADO NA LTIMA DATA NAO PRECISA PESQUISAR
	Else
		/// SE NO ESTIVER POSICIONADO LOCALIZA A LTIMA DATA PARA USAR A MESMA LOGICA
		dbSelectArea("CW0")
		dbSetOrder(1)
		dbSeek(cFilCW0+"LP"+cEmpAnt+Soma1(cFilAnt),.T.)
		dbSkip(-1)
		dDataLP := STOD(Substr(CW0->CW0_DESC01,1,8))
	EndIf

	CW0->(dbSkip(-1))
	While CW0->CW0_FILIAL == cFilCW0 .and. ALLTRIM(CW0->CW0_TABELA) == "LP" .and. ALLTRIM(CW0->CW0_CHAVE) == ALLTRIM(cEmpFil)
		If cTpSald == SubStr(CW0->CW0_DESC01,11,1)	/// TIPO DE SALDO DEVE SER VERIFICADO INDEPENDENTE DA MOEDA
			lMoedaChk := .T.
			/// SE FOR APURACAO DE MOEDA ESPECIFICA
			If lMoedaEsp .and. cMoeda <> SubStr(CW0->CW0_DESC01,9,2)
				lMoedaChk := .F.
			Endif
			If lMoedaChk	/// SE FOR A MESMA MOEDA / OU PROCESSAMENTO DE TODAS AS MOEDAS
				If Substr(CW0->CW0_DESC01,1,8) < cDataLP
					/// SE A DATA DE APURACAO FOR MENOR QUE A DATA FINAL DE APURACAO
					/// OBTEM A DATA DA APURACAO ANTERIOR
					dDTLPAnt := STOD(Substr(CW0->CW0_DESC01,1,8))
					Exit
				EndIf
			EndIf
		EndIf
		CW0->(dbSkip(-1))
	EndDo
EndIf

Return(dDTLPAnt)

/*


ͻ
Programa  CtLPCW0TabAutor  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.      Valida a existencia da tabela CW0 LP no ambiente           
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CtLPCW0Tab()
Local aArea := {}

If __lCW0LP == Nil
	aArea 	 := GetArea()

	dbSelectArea("CW0")
	CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
	If CW0->(MsSeek(xFilial("CW0") + "00" + "LP" )) .And. TamSx3("CW0_CHAVE")[1] >= 15
		__lCW0LP := .T.
	EndIf

	RestArea(aArea)

EndIf

Return __lCW0LP


/*


ͻ
Programa  CW0LPLoad Autor  Alvaro Camillo Neto  Data   30/11/10   
͹
Desc.      Faz a carga das informaes da tabela LP da CW0 a partir   
           da tabela LP da SX5                                        
͹
Uso        AP                                                        
ͼ


*/
Function CW0LPLoad()
Local aArea := GetArea()

dbSelectArea("CW0")
CW0->(dbSetOrder(1)) //CW0_FILIAL+CW0_TABELA+CW0_CHAVE
dbSelectArea("SX5")
SX5->(dbSetOrder(1)) //X5_FILIAL+X5_TABELA+X5_CHAVE

If CW0->(!MsSeek(xFilial("CW0") + "LP" ))
	If SX5->(MsSeek(xFilial("SX5") + "LP"))
		While SX5->(!EOF()) .And. Alltrim(SX5->(X5_FILIAL+X5_TABELA)) == Alltrim(xFilial("SX5") + "LP")
			If CW0->(!MsSeek(xFilial("CW0") + "LP" + SX5->X5_CHAVE ))
				Reclock("CW0",.T.)
				CW0->CW0_FILIAL := xFilial("CW0")
				CW0->CW0_TABELA	:= 'LP'
				CW0->CW0_CHAVE	:= SX5->X5_CHAVE
				CW0->CW0_DESC01 := SX5->X5_DESCRI
				MsUnlock()
			EndIf
			SX5->(dbSkip())
		EndDo
	EndIf
EndIf

RestArea(aArea)
Return

/*/

Ŀ
Funo    CW0SXBDtLP Autor  Alvaro Camillo Neto    Data  16.08.11 
Ĵ
Descrio Retorna a data formatada para o SX3 =>da Tabela LP do CW0   
Ĵ
Sintaxe   CtbSXBDtLP()                                                
ٱ


/*/
Function CW0SxbDtLP()

Return(DTOC(STOD(Subs(CW0->CW0_DESC01,1,8))))
/*/

Ŀ
Funo    CW0SXBMoed Autor  Alvaro Camillo Neto    Data  16.08.11 
Ĵ
Descrio Retorna a moeda 											  |
Ĵ
Sintaxe   CtbSXBMoed()                                                
ٱ


/*/
Function CW0SxbMoed()

Return((Subs(CW0->CW0_DESC01,9,2)))

/*/

Ŀ
Funo    CtbSXBTpSl Autor  Alvaro Camillo Neto    Data  16.08.11 
Ĵ
Descrio Retorna a moeda 											  |
Ĵ
Sintaxe   CtbSXBTpSl()                                                
ٱ


/*/
Function CW0SxbTpSl()

Return((Subs(CW0->CW0_DESC01,11,1)))

/*/

Ŀ
Funo    CtbRetSZ  Autor  Alvaro Camillo Neto    Data  16.08.11 
Ĵ
Descrio Retorna a data  											  |
Ĵ
Sintaxe   CtbRetSZ()                                                  
ٱ


/*/
Function CW0RetSZ()

Return(STOD(Subs(CW0->CW0_DESC01,1,8)))


/*/

Ŀ
Funo    CtbFltSZ Autor  Alvaro Camillo Neto    Data  16.08.11 
Ĵ
Descrio Retorna a data  											  |
Ĵ
Sintaxe   CtbRetSZ()                                                  
ٱ


/*/
Function CW0FltSZ()
Local cFiltro	:= ""
Local nTamCW0   := TamSX3("CW0_CHAVE")[1]
Local cEmpLP	:= Subs(CW0->CW0_CHAVE,1,2)
Local cFilLP	:= SUBS(CW0->CW0_CHAVE,3, nTamCW0)

cFiltro	:= Alltrim(CW0->CW0_TABELA) == 'LP' .And. cEmpLP = cEmpAnt .And. Alltrim(xFilial("CT2",cFilLP)) == Alltrim(xFilial("CT2",cFilAnt))

Return(cFiltro)

/*


ͻ
Programa  CW0LPSXB Autor   Alvaro Camillo Neto Data   16/08/11   
͹
Desc.      Consulta padrao de LP                                      
ͼ


*/
Function CW0LPSXB()

Local lRet		:= .T.
Local cSXB		:= ""

__dDataLP := STOD("")

If CtLPCW0Tab()
	cSXB := "CW0LP"
Else
	cSXB := "SX5LP"
EndIf

lRet	:= ConPad1( , , ,cSXB, /*cCampoRet*/,/*lGet*/,.F./*lOnlyView*/,/*cVar*/,/*oGet*/, /*uContent*/)

If CtLPCW0Tab()
	__dDataLP := CW0RETSZ()
Else
	__dDataLP := CTBRETSZ()
EndIf


Return lRet


/*


ͻ
Programa  CW0RETLP  Autor  Alvaro Camillo Neto  Data   16/08/11   
͹
Desc.     Retorna a data do LP                                        
                                                                      
͹
Uso        AP                                                        
ͼ


*/
Function CW0RETLP()
Return __dDataLP


/*


ͻ
Programa  CtbxSPNvl Autor  Alvaro Camillo Neto  Data   01/02/12   
͹
Desc.      Retorna o conteudo do campo da conta snttica de primeiro 
          nvel ( Exemplo 1: Ativo)                                   
͹
Uso        AP                                                        
ͼ


*/
Function CtbxSPNvl(cConta,cCampo,xDefault)
Local aArea 	:= GetArea()
Local aAreaCT1  := GetArea()
Local cConteud
Local cContaPNvl := ""

Default xDefault := ""

cConteud := xDefault

CT1->(dbSetOrder(1)) //CT1_FILIAL+CT1_CONTA

cContaPNvl := GetCT1SPNn(cConta)

If CT1->(MsSeek(xFilial("CT1") + cContaPNvl)) .And. CT1->(FieldPos(cCampo)) > 0
	cConteud:= CT1->(&(cCampo))
EndIf

RestArea(aAreaCT1)
RestArea(aArea)
Return cConteud


/*


ͻ
Programa  GetCT1SPNnAutor  Alvaro Camillo Neto  Data   01/02/12   
͹
Desc.     Retorna a conta sinttica de primeiro nvel                 
                                                                      
͹
Uso        CtbxSPNvl                                                  
ͼ


*/
Static Function GetCT1SPNn(cConta)
Local cContaPNvl := cConta

CT1->(dbSetOrder(1)) //CT1_FILIAL+CT1_CONTA

If CT1->(MsSeek(xFilial("CT1") + cConta))
	If Empty(CT1->CT1_CTASUP)
   		cContaPNvl := cConta
	Else // Faz recursividade at encontrar a conta que no possui superiora.
		cContaPNvl := GetCT1SPNn(CT1->CT1_CTASUP)
	EndIf
EndIf

Return cContaPNvl

/*/

Ŀ
Funo     CtbLegenda  Autor  Wagner Mobile Costa  Data  13.03.02 
Ĵ
Descrio  Funcao utilizada para criacao de Legenda SigaCtb           
           Retorna a legenda para o Browse/Cria caixa da legenda      
Ĵ
 Uso       SigaCtb                                                    
ٱ


/*/
Function CtbLegenda(cAlias, nReg)

Local aLegenda 	:= {}
Local uRetorno 	:= .T.
Local lX3STATSL	:= CV2->(FieldPos("CV2_STATSL") > 0)
LOcal cDescri := ""

if Type("lX3Aprova") == "U"
	lX3Aprova := If(GetNewPar("MV_ORCAPRV","S") == "S",.T.,.F.)
Endif

If nReg = Nil	// Chamada direta da funcao onde nao passa, via menu Recno eh passado
	uRetorno := {}
	If cAlias = "CT2"
		If CTBLCUso()
			Aadd(uRetorno, { "Substr(CT2->CT2_ROTINA,1,9) = '__CTBLC__'","f7_amar", STR0036} )    //"Lanamento complementar"
		Endif

		SX5->(DbSeek(xFilial("SX5") + "SL"))
		While SX5->X5_TABELA = "SL" .And. ! SX5->(Eof())
			If Left(SX5->X5_CHAVE, 1) = D_PRELAN
				cDescri := X5Descri()
			else
				cDescri := STR0037 + X5Descri()  //"Lancamento "
			endif
			Aadd(uRetorno, { 'CT2_TPSALD = "' + Left(SX5->X5_CHAVE, 1) + '"',;
							  CtbLegRes(Left(SX5->X5_CHAVE, 1)),;
							   cDescri} )

			SX5->(DbSkip())
		EndDo
	ElseIf cAlias = "CV1"
		Aadd(uRetorno, { 'CV1_STATUS = "3"', "f5_cinz" })
		If lAprova = Nil
			lAprova := 		(SX3->(DbSetOrder(2)), SX3->(DbSeek("CV1_APROVA")),;
		 					 SX3->(DbSetOrder(1)), X3Uso(SX3->X3_USADO))
		Endif
		If lAprova
			Aadd(uRetorno, { 'CV1_APROVA = " "', "f5_verm" })
			Aadd(uRetorno, { 'Ctb390Leg("1")', "f5_amar" })
		Else
			Aadd(uRetorno, { 'Ctb390Leg("2")', "f5_verm" })
		Endif
		Aadd(uRetorno, { 'Ctb390Leg("3")', "f5_azul" })
		Aadd(uRetorno, { 'Ctb390Leg("4")', "f5_verd" })
	ElseIf cAlias == "CV2"
		If lX3Aprova
			If lX3STATSL
				Aadd(uRetorno, { 'CV2->CV2_APROVA = " " .AND. CV2->CV2_STATUS = "1" .AND. CV2->CV2_STATSL <> "1"' 	, "f5_verm" })	/// NO APROVADO E S/ SALDO
				Aadd(uRetorno, { 'CV2->CV2_APROVA <> " " .AND. CV2->CV2_STATUS = "1" .AND. CV2->CV2_STATSL <> "1"'	, "f5_amar" })	/// APROVA  E S/ SALDO
			Else
				Aadd(uRetorno, { 'CV2->CV2_APROVA = " " .AND. CV2->CV2_STATUS = "1"'	, "f5_verm" })	/// NO APROVADO E S/ SALDO
				Aadd(uRetorno, { 'CV2->CV2_APROVA <> " " .AND. CV2->CV2_STATUS = "1"'	, "f5_amar" })	/// APROVA  E S/ SALDO
			EndIf
		Else
			If lX3STATSL
				Aadd(uRetorno, { 'CV2->CV2_STATUS = "1" .AND. CV2->CV2_STATSL <> "1"'	, "f5_verm" })	/// S/ SALDO (no h aprovao)
			Else
				Aadd(uRetorno, { 'CV2->CV2_STATUS = "1" ', "f5_verm" })	/// S/ SALDO (no h aprovao)
			EndIf
		Endif
		Aadd(uRetorno, { 'CV2->CV2_STATUS = "3"'								, "f5_cinz" })		/// ORCAMENTO REVISADO
		Aadd(uRetorno, { 'CV2->CV2_STATUS = "2"'								, "f5_verd" })		/// APROVADO GER.SALDO TOTAL
		If lX3STATSL
			Aadd(uRetorno, { 'CV2->CV2_STATUS = "1" .AND. CV2->CV2_STATSL = "1"', "f5_azul" })		/// APROVADO GER.SALDO PARCIAL
		Else
			Aadd(uRetorno, { 'Ctb390Lg2("2")'									, "f5_azul" })		/// APROVADO GER.SALDO PARCIAL
		EndIf
	ElseIf cAlias = "CTC"
		SX5->(DbSeek(xFilial("SX5") + "SL"))
		While SX5->X5_TABELA = "SL" .And. ! SX5->(Eof())
			If Left(SX5->X5_CHAVE, 1) = D_PRELAN
				cDescri := X5Descri()
			else
				cDescri := STR0037 + X5Descri()     //"Lancamento "
			endif
			Aadd(uRetorno, { 'CTC_TPSALD = "' + Left(SX5->X5_CHAVE, 1) + '"',;
							  CtbLegRes(Left(SX5->X5_CHAVE, 1)) , cDescri } )
			SX5->(DbSkip())
		EndDo
	Endif							// Inclui outros tratamento aqui
Else
	If cAlias = "CT2"
		SX5->(DbSeek(xFilial("SX5") + "SL"))
		While SX5->X5_TABELA = "SL" .And. ! SX5->(Eof())
			If Left(SX5->X5_CHAVE, 1) = D_PRELAN
				Aadd(aLegenda, { CtbLegRes(Left(SX5->X5_CHAVE, 1)), X5Descri() })
			Else
				Aadd(aLegenda, { CtbLegRes(Left(SX5->X5_CHAVE, 1)), STR0037 +  X5Descri() }) //"Lancamento "
			Endif
			SX5->(DbSkip())
		EndDo
		If CTBLCUso()
			Aadd(aLegenda, {"f7_amar",STR0036} ) //"Lanamento complementar"
		Endif
	ElseIf cAlias = "CV1"
		If lAprova
			aLegenda := { 	{ "f5_verm", "Orcamento nao aprovado" },;
							{ "f5_amar", "Orcamento aprovado sem saldo contabil" } }
		Else
			aLegenda := { 	{ "f5_verm", "Orcamento em aberto" } }
		Endif
		Aadd(aLegenda, { "f5_azul", "Saldo Contabil gerado parcialmente" })
		Aadd(aLegenda, { "f5_verd", "Saldo Contabil gerado total" })
		Aadd(aLegenda, { "f5_cinz", "Orcamento revisado" })
	ElseIf cAlias = "CV2"
		aLegenda := {}
		If lX3Aprova
			Aadd(aLegenda, { "f5_verm", "Orcamento nao aprovado" })
			Aadd(aLegenda, { "f5_amar" , "Orcamento aprovado sem saldo contabil" })
		Else
			Aadd(aLegenda, { "f5_verm", "Orcamento sem saldo gerado" })
		Endif
		Aadd(aLegenda, { "f5_azul"	  , "Saldo Contabil gerado parcialmente" })
		Aadd(aLegenda, { "f5_verd"   , "Saldo Contabil gerado total" })
		Aadd(aLegenda, { "f5_cinz"   , "Orcamento revisado" })
		///Aadd(aLegenda, { "BR_PRETO"   , " " })
	ElseIf cAlias = "CTC"
		SX5->(DbSeek(xFilial("SX5") + "SL"))
		While SX5->X5_TABELA = "SL" .And. ! SX5->(Eof())
			If Left(SX5->X5_CHAVE, 1) = D_PRELAN
				Aadd(aLegenda, { CtbLegRes(Left(SX5->X5_CHAVE, 1)), X5Descri() })
			Else
				Aadd(aLegenda, { CtbLegRes(Left(SX5->X5_CHAVE, 1)), STR0037 +  X5Descri() }) //"Lancamento "
			Endif
			SX5->(DbSkip())
		EndDo
	Endif				           			// Inclui outros tratamento aqui

	BrwLegenda(cCadastro, STR0038, aLegenda) //"Legenda"
Endif

Return uRetorno

/*/


Ŀ
Program    CtbLegRes   Autor  Wagner Mobile Costa  Data  13.02.02 
Ĵ
Descrio  Retorna o resource a ser utilizado na legenda              
Ĵ
Sintaxe   CtbLegRes()                                                 
Ĵ
Retorno    lPar1 = Indica se eh ou nao um saldo interno               
           lPar2 = Indica se apresenta ou nao mensagem                
Ĵ
Uso       SigaCtb                                                     
Ĵ
Parametros ExpC1 = Codigo do saldo sendo verificado                   
ٱ


/*/
Function CtbLegRes(cSaldo)

Local cResource := ""
Local aArea 	:= GetArea()
Local aAreaSx5 	:= SX5->(GetArea())
Local aLegenda 	:= { "f5_null", "f5_verd", "f5_amar", "f5_azul", "f5_marr", "f5_verm", "f7_null" }

If SX5->(DbSeek(xFilial() + "SM" + cSaldo))
	cResource := AllTrim(SX5->X5_DESCRI)
Endif

If Empty(cResource) .And. Ctb130SldInt(cSaldo, .F.)
	If cSaldo < "5"
		cResource := aLegenda[Val(cSaldo) + 1]
	ElseIf cSaldo = D_PRELAN
		cResource := aLegenda[Len(aLegenda)]
	Endif
Endif

SX5->(RestArea(aAreaSx5))
RestArea(aArea)

Return cResource

/*/


Ŀ
Funo    Ctb390Leg  Autor  Wagner Mobile Costa    Data  06.11.02 
Ĵ
Descrio  Rotina de retorno para amentaria                           
Ĵ
 Uso       Ctba390                                                    
ٱ


/*/
Function Ctb390Leg(cTpLegenda)

Local nRecno, nIndex := CV1->(IndexOrd())
Local nAprvSSld := nAberto := nTotal := nLidos := 0, lRet := .F.

Static cSeqMostra

If cSeqMostra = Nil
	cSeqMostra := StrZero(1,TamSx3("CV1_SEQUEN")[1])
Endif

M->CV1_ORCMTO	:= CV1->CV1_ORCMTO
M->CV1_CALEND	:= CV1->CV1_CALEND
M->CV1_MOEDA	:= CV1->CV1_MOEDA
M->CV1_REVISA	:= CV1->CV1_REVISA
nRecno := CV1->(Recno())
CV1->(DbSetOrder(1))
CV1->(DbGoto(nRecno))

While CV1->CV1_FILIAL+CV1->CV1_ORCMTO+CV1->CV1_CALEND+CV1->CV1_MOEDA+CV1->CV1_REVISA=;
	  xFilial("CV1")+M->CV1_ORCMTO+M->CV1_CALEND+M->CV1_MOEDA+M->CV1_REVISA .And.;
	  ! CV1->(Eof())
	If lAprova .And. ! Empty(CV1->CV1_APROVA) .And. CV1->CV1_STATUS = "1"
		nAprvSSld ++
	ElseIf CV1->CV1_STATUS = "1"
		nAberto ++
	ElseIf CV1->CV1_STATUS = "2"
		nTotal ++
	Endif
	nLidos ++
	CV1->(DbSkip())
EndDo

CV1->(DbSetOrder(nIndex))
CV1->(DbGoto(nRecno))

If cTpLegenda = "1" .And. nAprvSSld = nLidos
	lRet := .T.
ElseIf cTpLegenda = "2" .And. nAberto = nLidos
	lRet := .T.
ElseIf cTpLegenda = "3" .And. nAberto > 0 .And. nTotal > 0
	lRet := .T.
ElseIf cTpLegenda = "4" .And. nTotal = nLidos
	lRet := .T.
Endif

Return lRet

/*/


Ŀ
Funo    Ctb390Lg2  Autor  Marcos S. Lobo         Data  16.07.03 
Ĵ
Descrio  Rotina de retorno para legenda da rotina de oramentos CTB 
Ĵ
 Uso       Ctba390                                                    
ٱ


/*/
Function Ctb390Lg2(cTpLegenda)

Local lRet	  := .F.
Local nIndCV1 := CV1->(IndexOrd())
Local nRecCV1 := CV1->(Recno())
Local nLidos  := nGerados := 0
Local cFilCV2 := xFilial("CV2")

DEFAULT cTPLegenda	:= "1" ///Testar Condio 1= Saldo Totalmente Gerado / 2= Saldo Parcialmente Gerado

Public M->CV2_FILIAL	:= CV2->CV2_FILIAL
Public M->CV2_ORCMTO	:= CV2->CV2_ORCMTO
Public M->CV2_CALEND	:= CV2->CV2_CALEND
Public M->CV2_MOEDA		:= CV2->CV2_MOEDA
Public M->CV2_REVISA	:= CV2->CV2_REVISA

dbSelectArea("CV1")
dbSetOrder(1)
If MsSeek(cFilCV2+CV2->(CV2_ORCMTO+CV2_CALEND+CV2_MOEDA+CV2_REVISA))
	While !CV1->(Eof()) .and. cFilCV2+CV2->(CV2_ORCMTO+CV2_CALEND+CV2_MOEDA+CV2_REVISA) == CV1->(CV1_FILIAL+CV1_ORCMTO+CV1_CALEND+CV1_MOEDA+CV1_REVISA)
		nLidos += 1
		If CV1->CV1_STATUS == "2"
			nGerados += 1
		Endif
		CV1->(dbSkip())
	Enddo
Endif

if Type("lX3Aprova") == "U"
	lX3Aprova := If(GetNewPar("MV_ORCAPRV","S") == "S",.T.,.F.)
Endif

CV1->(dbSetOrder(nIndCV1))
CV1->(dbGoTo(nRecCV1))

DO CASE
CASE cTpLegenda = "1"	/// CONDIO PARA SALDO CONTABIL GERADO TOTAL
	If Iif(lX3Aprova,!Empty(CV2->CV2_APROVA),.T.) .and. nLidos == nGerados
		lRet := .T.		/// SE ESTIVER APROVADO E A QUANTIDADE DE REGISTROS (DETALHE) LIDOS = A QUANTIDADE DE GERADOS
	Endif
CASE cTpLegenda = "2" /// CONDIO PARA SALDO CONTABIL GERADO PARCIALMENTE
	If Iif(lX3Aprova,!Empty(CV2->CV2_APROVA),.T.) .and. nLidos <> nGerados
		lRet := .T.	/// SE ESTIVER APROVADO E A QUANTIDADE DE REGISTROS (DETALHE) LIDOS <> A QUANTIDADE DE GERADOS
	Endif
OTHERWISE
	lRet := .T.
ENDCASE

Return lRet

/*/


Ŀ
Funo    CTBINTRAN  Autor  Totvs                  Data  23.10.08 
Ĵ
Descrio  Indica se a contabilizacao pode ser executada dentro de    
           uma transacao                                              
Ĵ
 Uso       Ctbxmix                                                    
Ĵ
Parametros ExpN1 = 0 para testar se pode ou nao executar em uma       
                   transacao sem mensagens;                           
                 = 1 para verificar retornando as razoes pelas quais a
                   contabilizacao nao pode ser executada na transacao 
           ExpL1 = se ira ira mostrar o lancamento                    
ٱ


/*/
Function CtbInTran( nModo, lMostraLCTO )
	Local lRet		:= .T.
	Local cMensagem	:= ""

	DEFAULT lMostraLCTO := .T.

	If lMostraLCTO
	      lRet		:= .F.
	      cMensagem += IIf( nModo == 1, STR0039, "" ) + CRLF    //"Opo Mostra Lctos. Contb. habilitada"
	EndIf

	If GetMV( "MV_ALTLCTO" ) == "S"
	      lRet 		:= .F.
	      cMensagem += IIf(nModo == 1, STR0040, "" ) + CRLF  //"Parmetro MV_ALTLCTO habilitado"
	EndIf

	If !(cPaisLoc <> "RUS" .and. FWIsInCallStack('AF012EXCLT'))

		If SuperGetMV( "MV_PRELAN", .F., "N" ) == "N"
			lRet 		:= .F.
			cMensagem += IIf(nModo == 1, STR0041, "" ) + CRLF  //"Parmetro MV_PRELAN desabilitado"
	    EndIf
	Endif

	If SuperGetMV( "MV_CT105MS", .F., "S" ) == "S"
	      lRet 		:= .F.
	      cMensagem += IIf(nModo == 1, STR0042, "" ) + CRLF  //"Parmetro MV_CT105MS habilitado"
	EndIf

	If !lRet .AND. nModo == 1
	      Help( " ", 1, "HELP",, STR0043 + CRLF + cMensagem, 1, 0 )  //"A contabilizao no pode ser executada "
	EndIf
Return lRet
/*


ͻ
Programa  CTBXFUNA  Autor  Marcos S. Lobo       Data   04/20/07   
͹
Desc.     Efetua verificao e retorna se a integridade referencial   
          esta em uso                                                 
͹
Uso        AP-Rotinas com chamada de Stored Procedures                
ͼ


*/
Function FkInUse(cEmpAtu)
Local aArea
Local lFKemuso 		:= .F.
Local cEmpDefault 	:= IIF(FindFunction("FWGRPCompany"), FWGRPCompany(),SM0->M0_CODIGO)

DEFAULT cEmpAtu 	:= cEmpDefault
aArea	:= GetArea()

//Ŀ
// Verifica se a integridade referencial est ativa                          
//
cQuery := "SELECT count(*) TOTAL FROM TOP_PARAM WHERE PARAM_NAME = 'FKINUSE" + cEmpAtu + "'"

If Select("INTEGR") > 0
	dbSelectArea("INTEGR")
	dbCloseArea()
EndIf

dbUseArea(.T., "TOPCONN", TCGenQry(,,cQuery), 'INTEGR', .F., .T.)
dbSelectArea("INTEGR")
lFKemuso := If( INTEGR->TOTAL > 0, .T., .F.)
dbCloseArea()
RestArea(aArea)

Return(lFKemuso)

/*/

Ŀ
Funo    CTBExpCSV  Autor  Marcelo Akama          Data  12/08/09 
Ĵ
Descrio  Exportacao de tabelas para arquivo .CSV                    
Ĵ
Sintaxe   CTBExpCSV(lEnd, oProcess, cArq, aTables)                    
Ĵ
Retorno   Nenhum                                                      
Ĵ
Uso       GENERICO                                                    
Ĵ
Parametros ExpL1 = lEnd do MsNewProcess                               
           ExpO1 = Objeto MsNewProcess                                
           ExpC1 = Nome do arquivo a ser gerado                       
           ExpA1 = Array com os alias das tabelas a serem exportadas  
                   Ex.: {"CT1", "CVD"}                                
ٱ


/*/

Function CTBExpCSV(lEnd, oProcess, cArq, aTables)
Local aStruct	:=	{}
Local cLin		:=	""
Local aArea		:= GetArea()
Local aAreaAux
Local cAux
Local nX,nY
Local nRec,nTot
Local cID

SAVEINTER()

If At('.',cArq) == 0
	cArq	:=	AllTrim(cArq)+'.CSV'
EndIf
 	If (nHandle := FCreate(cArq))== -1
	Alert(STR0044) //"Erro na criacao do arquivo!"
	Return
EndIf

// Lista de tabelas
cLin:="0"
For nY := 1 to len(aTables)
	cLin += ';'+aTables[nY,1]
Next
cLin += CRLF
FWrite(nHandle,cLin,Len(cLin))

oProcess:SetRegua1(len(aTables)*2)

For nY := 1 to len(aTables)
	oProcess:IncRegua1(STR0045+' '+aTables[nY,1]) //"Lendo estrutura da tabela"
	cId		:= Alltrim(str(nY))
	cLin	:= cId
	aStruct	:=(aTables[nY,1])->(DbStruct())
	For nX:=1 To Len(aStruct)
		cLin	+=	';'+aStruct[nX,1]
	Next
	cLin += CRLF
	FWrite(nHandle,cLin,Len(cLin))

	aAreaAux := (aTables[nY,1])->(GetArea())
	DbSelectArea(aTables[nY,1])
	DbSetOrder(aTables[nY,2])
	DbGoTop()
	nTot := 0
	nRec := 0
	dbEval( {|x| nTot++ },,{|| !Eof()} )

	oProcess:IncRegua1(STR0046+' '+aTables[nY,1]) //"Exportando tabela"
	oProcess:SetRegua2(nTot)
	DbGoTop()
	Do While !Eof()
		cLin :=cId
		For nX := 1 To Len(aStruct)
			Do Case
				Case aStruct[nX,2] == "C"
					cLin += ';'+FieldGet(FieldPos(aStruct[nX,1]))
				Case aStruct[nX,2] == "L"
					cLin += ';'+IIf(FieldGet(FieldPos(aStruct[nX,1])),"T","F")
				Case aStruct[nX,2] == "D"
					cLin += ';'+Dtos(FieldGet(FieldPos(aStruct[nX,1])))
				Case aStruct[nX,2] == "N"
					cLin += ';'+Str(FieldGet(FieldPos(aStruct[nX,1])))
				Otherwise
					cLin += ';'
			EndCase
		Next
		cLin += CRLF
		FWrite(nHandle,cLin,Len(cLin))
		DbSkip()
		nRec++
		oProcess:IncRegua2(Alltrim(Str(nRec))+'/'+Alltrim(Str(nTot)))
	EndDo
	RestArea(aAreaAux)
Next

FClose(nHandle)

Aviso(STR0047,STR0048,{STR0049}) //"Finalizado"###"Exportacao gerada com sucesso" //"Ok"

RestInter()

RestArea(aArea)

Return .T.


/*/

Ŀ
Funo    CTBImpCSV  Autor  Marcelo Akama          Data  12/08/09 
Ĵ
Descrio  Importacao de tabelas de arquivo .CSV                      
Ĵ
Sintaxe   CTBImpCSV(lEnd, oProcess, cArq, aCfg)                    
Ĵ
Retorno   Nenhum                                                      
Ĵ
Uso       GENERICO                                                    
Ĵ
Parametros ExpL1 = lEnd do MsNewProcess                               
           ExpO1 = Objeto MsNewProcess                                
           ExpC1 = Nome do arquivo a ser importado                    
           ExpA1 = Array com configuracoes de importacao no formato:  
                           {cAlias [ , [cCampos] [,bBloco] ] }        
                   Onde:                                              
                      cAlias  = Alias da tabela                       
                      cCampos = Campos para importar (default: Todos) 
                      bBloco  = Bloco de codigo para inclusao custom. 
                   Ex.: { {"CT1","CT1_CONTA,CT1_CLASSE",{|| } }       
ٱ


/*/

Function CTBImpCSV(lEnd, oProcess, cArq, aCfg , lProc)
Local aTables	:= {}
Local lOk		:= .F.
Local aArea		:= GetArea()
Local aStruc
Local aPos
Local cLinha
Local nAt
Local cToken
Local nX
Local cID
Local nTable
Local nTot
Local nPos
Local nPosCpo
Local nPosNil
Local xAutoCab
Local aTxt
Local bAppend
Local cIdCV8	:= ""
Local nY
Local cDetalhe := ""
Local aLog :={}
Local cProcesso := FunName()+".IMP"
Default lProc := .T.

Private lMsErroAuto		:= .F.
Private lMsHelpAuto		:= .T.
Private lAutoErrNoFile	:= .T.

SaveInter()


If (nHandle := FT_FUse(AllTrim(cArq)))== -1
	Help(" ",1,"NOFILEIMPOR")
	RestInter()
	Return .F.
EndIf

nTot:=FT_FLASTREC()
oProcess:SetRegua1(nTot)

FT_FGOTOP()

cLinha 	:= FT_FREADLN()
FT_FSKIP()
oProcess:IncRegua1(STR0050) //"Lendo arquivo..."

If Left( cLinha, 2 ) <> "0;"
	Aviso(STR0051,STR0052,{STR0053}) //"Estrutura incorreta."###"Cabecalho nao encontrado"###"Abandona"
	RestInter()
	Return .F.
EndIf

cLinha := Right( cLinha, Len( cLinha ) -2 )
nAt		:=	1
Do While nAt > 0
	nAt	:=	AT(";",cLinha)
	If nAt == 0
		cToken := cLinha
	Else
		cToken	:=	Substr(cLinha,1,nAt-1)
	EndIf

	cToken := Alltrim(cToken)

	If !Empty(cToken)
		AADD( aTables, cToken )
	EndIf
	cLinha	:=	Substr(cLinha,nAt+1)
EndDo

If valtype(aCfg)<>"A"
	aCfg := {}
	For nX := 1 to len(aTables)
		AADD(aCfg, {aTables[nX],,})
	Next
Else
	For nX := 1 to len(aCfg)
		If aScan( aTables, aCfg[nX,1] ) == 0
			Aviso(STR0051,STR0032+" "+aCfg[nX,1]+" "+STR0034,{STR0053}) //"Estrutura incorreta."###"Tabela ### nao encontrada."###"Abandona"
			FT_FUSE()
			RestInter()
			Return .F.
		EndIf
	Next
EndIf

If lProc
	ProcLogIni( {},cProcesso ,,@cIdCV8 )
	ProcLogAtu( "INICIO" , STR0054 ,,,.T. ) //"Importao"
EndIf


nTable	:= 0
cID		:= '0'
Do While !FT_FEOF()
	cLinha	:= FT_FREADLN()
	FT_FSKIP()
	oProcess:IncRegua1(STR0050)  //"Lendo arquivo..."

	nAt		:= AT(";",cLinha)
	cToken	:= Substr(cLinha,1,nAt-1)
	cLinha	:= Right( cLinha, Len( cLinha ) - nAt )
	If !Empty(cLinha)
		If cToken<>cID
			nTable++
			cID	:= Alltrim(Str(nTable))

			If cToken<>cID
				Aviso(STR0051,STR0032+" "+aTables[nTable]+" "+STR0034,{STR0053}) //"Estrutura incorreta."###"Tabela ### nao encontrada."###"Abandona"
				FT_FUSE()
				RestInter()
				Return .F.
			Else
				nPos := aScan( aCfg, { |x| x[1] == aTables[nTable] } )
				lOk	 := nPos>0
				If lOk
					If valtype(aCfg[nPos,2])=="A"
						aCampos := aCfg[nPos,2]
					Else
						aCampos := (aTables[nTable])->( DbStruct() )
					EndIf

					If valtype(aCfg[nPos,3])=="B"
						bAppend := aCfg[nPos,3]
					Else
						bAppend := nil
					EndIf

					aPos := Array( Len( aCampos ) )

					nPos	:=	0
					nAt		:=	1
					Do While nAt > 0
						nPos++
						nAt	:=	AT(";",cLinha)
						If nAt == 0
							cToken := cLinha
						Else
							cToken := Substr(cLinha,1,nAt-1)
						EndIf

						If ASCAN(aCampos,{|aCpo| Alltrim(aCpo[1]) == Alltrim(cToken)}) <= 0
							cLinha	:=	Substr(cLinha,nAt+1)
							Loop
						EndIf

						nPosCpo	:=	aScan( aCampos, { |x| x[1] == cToken } )
						If nPosCpo > 0
							aPos[nPosCpo]:= nPos
						EndIf
						cLinha	:=	Substr(cLinha,nAt+1)
					EndDo
					While ( nPosNil := aScan( aPos, Nil ) ) > 0
						aPos[nPosNil]:= ++nPos
					End
					If (nPosNil:= Ascan(aPos,Nil)) > 0
						Aviso(STR0051,STR0055+" "+aCampos[nPosNil][1]+" "+STR0056,{STR0053}) //"Estrutura incorreta."###"O campo "###" nao foi achado na estrutura, por favor verificar."###"Abandona"
						FT_FUSE()
						RestInter()
						Return .F.
					EndIf
				EndIf
			EndIf
		Else
			If lOk
				nPos := 0
				aTxt := {}
				Do While At(";",cLinha)>0
					aAdd(aTxt,Substr(cLinha,1,At(";",cLinha)-1))
					nPos ++
					cLinha := StrTran(Substr(cLinha,At(";",cLinha)+1,Len(cLinha)-At(";",cLinha)),'"','')
				EndDo
				If Len(AllTrim(cLinha)) > 0
					aAdd(aTxt,StrTran(Substr(cLinha,1,Len(cLinha)),'"','') )
				Else
					aAdd(aTxt,"")
				EndIf

				While aPos[Len(aPos)] > Len( aTxt )
					aAdd( aTxt, "" )
				End
				xAutoCab := {}
				For nX:=1 To Len(aCampos)

					If Len(alltrim(aTxt[aPos[nX]]))>0
						Do Case
						Case Right(aCampos[nX][1], 7) == "_FILIAL"

						Case aCampos[nX][2] == "C"
							AADD(xAutoCab,{aCampos[nX][1] , aTxt[aPos[nX]] , Nil})

						Case aCampos[nX][2] == "L"
							AADD(xAutoCab,{aCampos[nX][1] , aTxt[aPos[nX]]=="T" , Nil})

						Case aCampos[nX][2] == "D"
							AADD(xAutoCab,{aCampos[nX][1] , STOD( aTxt[aPos[nX] ] ) , Nil})

						Case aCampos[nX][2] == "N"
							AADD(xAutoCab,{aCampos[nX][1] , Val( aTxt[aPos[nX]] ) , Nil})

						EndCase
					EndIf

				Next

				If valtype(bAppend) == "B"
					Eval(bAppend)
					MsUnLockAll()
					FreeUsedCode(.T.)
					If lMsErroAuto
						aLog := GETAUTOGRLOG()
						lMsErroAuto := .F.
						lRet := .F.
						cDetalhe := ""

						For nY := 1 to Len(aLog)
							cDetalhe += aLog[nY]+CHR(10)
						Next nY
						If lProc
							ProcLogAtu( "ERRO", STR0057 ,cDetalhe,,.T.)//"Erro na Incluso"
						EndIf
					Endif
				Else
					RecLock(aTables[nTable],.T.)
					For nX:=1 To Len(xAutoCab)
						FieldPut(FieldPos(xAutoCab[nX,1]), xAutoCab[nX,2])
					Next
					MsUnLock()
				EndIF
			EndIf
		EndIf
	EndIf
EndDo

FT_FUSE()

If lProc
	ProcLogAtu( "FIM",,,,.T. )
	ProcLogView(cFilAnt,'CTBImpCSV',,cIdCV8 )
EndIf

RestInter()

RestArea(aArea)

Return .T.

//-------------------------------------------------------------------
/*{Protheus.doc} CtbFilVers()
Filtro

@author Simone Mie Sato Kakinoana

@version P12
@since   27/03/2015
@return  Nil
@obs
*/
//-------------------------------------------------------------------
Function CtbFilVers()
Local lRet	:= .T.

lRet := CVN->CVN_CODPLA == cPlanoRef .And. CVN->CVN_VERSAO == cVersao

Return(lRet)
